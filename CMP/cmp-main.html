<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CMP 자동화 테스트</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* 공통 입력란 스타일 */
        .form-group input,
        .form-group select,
        .user-row input,
        .user-row select {
            height: 38px !important;
            padding: 8px 12px !important;
            border: 1px solid #ddd !important;
            border-radius: 4px !important;
            width: 100% !important;
            font-size: 14px !important;
        }

        /* 드롭다운 리스트 스타일 */
        .form-group select,
        .user-row select,
        select.user-role,
        select.user-system-role {
            appearance: none !important;
            -webkit-appearance: none !important;
            -moz-appearance: none !important;
            background: #ffffff url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24'%3E%3Cpath fill='%23333333' d='M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z'/%3E%3C/svg%3E") no-repeat right 8px center !important;
            background-size: 16px !important;
            padding-right: 32px !important;
            color: #333333 !important;
        }

        /* 드롭다운 옵션 스타일 */
        .form-group select option,
        .user-row select option,
        select.user-role option,
        select.user-system-role option {
            background: #ffffff !important;
            color: #333333 !important;
            padding: 8px !important;
        }
        
        /* 프로젝트 설정과 저장소 설정의 입력창 스타일 */
        #modalProjectCode, #modalProjectName, #modalRepositoryName {
            background-color: #f5f5f5 !important;
            color: #666 !important;
            cursor: not-allowed !important;
            opacity: 0.8 !important;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }



        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: #e3f2fd;
            min-height: 100vh;
            overflow-x: hidden;
            overflow-y: auto;
            color: #000000;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .app-container {
            display: flex;
            min-height: 100vh;
            background: #ffffff;
            backdrop-filter: blur(20px);
            transition: background 0.3s ease;
        }

        /* LNB (Left Navigation Bar) */
        .lnb {
            width: 280px;
            min-width: 280px;
            max-width: 280px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(0, 0, 0, 0.1);
            color: #000000;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            position: sticky;
            top: 0;
            height: 100vh;
            max-height: 100vh;
            overflow: hidden;
            transition: background 0.3s ease, border-right 0.3s ease, color 0.3s ease;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.1);
        }

        .lnb-header {
            padding: 30px 20px;
            text-align: center;
            border-bottom: 1px solid rgba(0,0,0,0.1);
            background: rgba(255,255,255,0.5);
            backdrop-filter: blur(10px);
            height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
        }

        .back-button {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.2);
            color: #000000;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
            z-index: 9999;
        }

        .back-button:hover {
            background: rgba(0, 0, 0, 0.2);
            transform: translateX(2px);
        }

        .lnb-header h1 {
            font-size: 1.8em;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            font-weight: 700;
            color: #000000;
            line-height: 1.2;
            height: 2.2em;
        }

        .lnb-header p {
            font-size: 0.9em;
            opacity: 0.7;
            font-weight: 300;
        }

        /* 테마 토글 버튼 */
        .theme-toggle {
            text-align: center;
            padding: 15px 0;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .theme-toggle-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #ffffff;
            font-size: 16px;
        }

        .theme-toggle-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        /* 라이트 모드 스타일 */
        body.light-theme {
            background: #ffffff;
            color: #2c3e50;
            overflow-x: hidden;
            overflow-y: auto;
        }

        body.light-theme .app-container {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 50%, #e9ecef 100%);
        }

        body.light-theme .lnb {
            background: #ffffff;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            color: #2c3e50;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.1);
        }

        body.light-theme .lnb-header {
            background: rgba(255,255,255,0.02);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            color: #2c3e50;
        }

        body.light-theme .lnb-header h1 {
            background: linear-gradient(135deg, #1d80f8 0%, #1565c0 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
            letter-spacing: 1px;
            font-size: 1.8em;
            line-height: 1.2;
            height: 2.2em;
            margin: 0;
            padding: 0;
        }

        body.light-theme .lnb-header p {
            color: rgba(44, 62, 80, 0.7);
        }

        body.light-theme .theme-toggle {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        body.light-theme .theme-toggle-btn {
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.2);
            color: #2c3e50;
        }

        body.light-theme .theme-toggle-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        body.light-theme .nav-item {
            color: #2c3e50;
            background: rgba(255, 255, 255, 0.7);
            border: 1px solid #e9ecef;
            margin: 8px 15px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        body.light-theme .nav-item:hover {
            background: rgba(102, 126, 234, 0.1);
            border-color: #1d80f8;
            transform: translateX(3px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        body.light-theme .nav-item.active {
            background: linear-gradient(135deg, #1d80f8 0%, #1565c0 100%);
            color: #ffffff;
            border-color: #1d80f8;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        body.light-theme .nav-item.active i,
        body.light-theme .nav-item.active span {
            color: #ffffff;
        }

        body.light-theme .main-content {
            background: #ffffff;
        }

        body.light-theme .content-header h2 {
            color: #2c3e50;
        }

        body.light-theme .content-header p {
            color: #6c757d;
        }

        body.light-theme .scenario-card {
            background: #ffffff;
            border: 1px solid #e9ecef;
            color: #2c3e50;
        }

        body.light-theme .scenario-card:hover {
            border-color: #1d80f8;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.15);
            transform: translateY(-2px);
        }

        body.light-theme .scenario-title {
            color: #2c3e50 !important;
            font-weight: 600;
        }

        body.light-theme .scenario-description {
            color: #6c757d !important;
        }

        /* 라이트 모드에서 시나리오 카드 내부 모든 텍스트 색상 */
        body.light-theme .scenario-card * {
            color: #2c3e50 !important;
        }

        body.light-theme .scenario-card .scenario-description,
        body.light-theme .scenario-card .scenario-status,
        body.light-theme .scenario-card .status-badge {
            color: #6c757d !important;
        }

        body.light-theme .summary-card {
            background: #ffffff;
            border: 1px solid #e9ecef;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        body.light-theme .summary-card:hover {
            border-color: #1d80f8;
            box-shadow: 0 20px 40px rgba(102, 126, 234, 0.2);
        }

        body.light-theme .summary-card .label {
            color: #6c757d;
        }



        body.light-theme .btn-primary {
            background: linear-gradient(135deg, #1d80f8 0%, #1565c0 100%);
            color: #ffffff;
            border-color: #1d80f8;
        }

        body.light-theme .btn-secondary {
            background: #6c757d;
            color: #ffffff;
            border-color: #6c757d;
        }

        body.light-theme .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: #ffffff;
            border-color: #28a745;
        }

        body.light-theme .btn-danger {
            background: linear-gradient(135deg, #dc3545 0%, #fd7e14 100%);
            color: #ffffff;
            border-color: #dc3545;
        }

        body.light-theme .btn-info {
            background: linear-gradient(135deg, #17a2b8 0%, #6f42c1 100%);
            color: #ffffff;
            border-color: #17a2b8;
        }

        body.light-theme .btn-warning {
            background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%);
            color: #2c3e50;
            border-color: #ffc107;
        }

        body.light-theme .btn-recording {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: #ffffff;
            border-color: #e74c3c;
        }

        body.light-theme .btn-recording.active {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            border-color: #27ae60;
        }

        body.light-theme .btn-label {
            color: inherit;
        }

        /* 라이트 모드에서 로그창 스타일 */
        body.light-theme .scenario-log .log-header {
            background: linear-gradient(135deg, #ecf0f1 0%, #bdc3c7 100%) !important;
            border: 1px solid #e9ecef !important;
            color: #2c3e50 !important;
        }

        body.light-theme .scenario-log .log-content {
            background: #ffffff !important;
            border: 1px solid #e9ecef !important;
            color: #2c3e50 !important;
        }

        /* 라이트 모드에서 로그 텍스트 색상 */
        body.light-theme .scenario-log .log-content div {
            color: #2c3e50 !important;
            border-bottom: 1px solid #e9ecef !important;
        }

        body.light-theme .scenario-log .log-content span {
            color: #2c3e50 !important;
        }

        body.light-theme .scenario-log .log-content span[style*="color: rgba(255, 255, 255, 0.7)"] {
            color: #6c757d !important;
        }

        body.light-theme .scenario-log .log-content span[style*="color: rgba(255, 255, 255, 0.9)"] {
            color: #2c3e50 !important;
        }

        body.light-theme .status-badge {
            border: 1px solid #e9ecef;
        }

        body.light-theme .status-badge.ready {
            background: #e9ecef;
            color: #6c757d;
        }

        body.light-theme .status-badge.running {
            background: #fff3cd;
            color: #856404;
        }

        body.light-theme .status-badge.pass,
        body.light-theme .status-badge.pass {
            background: #d4edda;
            color: #155724;
        }

        body.light-theme .status-badge.failed,
        body.light-theme .status-badge.fail {
            background: #f8d7da;
            color: #721c24;
        }

        body.light-theme .status-badge.stopped {
            background: #e2e3e5;
            color: #6c757d;
        }

        body.light-theme .scenario-checkbox-label {
            border: 2px solid #e9ecef;
        }

        body.light-theme .scenario-checkbox-label:before {
            background: #1d80f8;
        }

        body.light-theme .scenario-history {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
        }

        body.light-theme .scenario-history-item {
            background: #ffffff;
            border: 1px solid #e9ecef;
        }

        body.light-theme .scenario-history-item:hover {
            background: rgba(102, 126, 234, 0.05);
            border-color: #1d80f8;
        }





        body.light-theme .btn-dark {
            background: linear-gradient(135deg, #343a40 0%, #495057 100%);
            color: #ffffff;
            border-color: #343a40;
        }

        /* 라이트 모드 도넛 버튼 스타일 */
        body.light-theme .donut-center-btn {
            background: linear-gradient(135deg, #1d80f8 0%, #1565c0 100%);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        body.light-theme .donut-center-btn:hover {
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        body.light-theme .donut-item {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        body.light-theme .donut-item:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        }

        /* 라이트 모드 더보기 메뉴 스타일 */
        body.light-theme .more-btn {
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.2);
            color: #2c3e50;
        }

        body.light-theme .more-btn:hover {
            background: rgba(0, 0, 0, 0.2);
        }

        body.light-theme .more-menu {
            background: rgba(255, 255, 255, 0.95);
            color: #2c3e50;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            min-width: 280px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
        }

        body.light-theme .more-item {
            color: #2c3e50;
        }

        body.light-theme .more-item:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        /* 라이트 모드 메뉴 항목별 색상 */
        body.light-theme .more-run {
            color: #27ae60 !important;
        }
        body.light-theme .more-run:hover {
            background: rgba(39, 174, 96, 0.1) !important;
        }

        body.light-theme .more-stop {
            color: #e74c3c !important;
        }
        body.light-theme .more-stop:hover {
            background: rgba(231, 76, 60, 0.1) !important;
        }

        body.light-theme .more-settings {
            color: #f39c12 !important;
        }
        body.light-theme .more-settings:hover {
            background: rgba(243, 156, 18, 0.1) !important;
        }

        body.light-theme .more-record {
            color: #9b59b6 !important;
        }
        body.light-theme .more-record:hover {
            background: rgba(155, 89, 182, 0.1) !important;
        }

        body.light-theme .more-report {
            color: #3498db !important;
        }
        body.light-theme .more-report:hover {
            background: rgba(52, 152, 219, 0.1) !important;
        }

        body.light-theme .more-history {
            color: #1abc9c !important;
        }
        body.light-theme .more-history:hover {
            background: rgba(26, 188, 156, 0.1) !important;
        }

        body.light-theme .more-reset {
            color: #e67e22 !important;
        }
        body.light-theme .more-reset:hover {
            background: rgba(230, 126, 34, 0.1) !important;
        }





        .lnb-nav {
            flex: 1;
            padding: 20px 0;
        }

        .nav-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border-left: 3px solid transparent;
            margin: 8px 15px;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
        }

        .nav-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(52, 152, 219, 0.1);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .nav-item:hover::before {
            opacity: 1;
        }

        .nav-item:hover {
            transform: translateX(5px);
            border-left-color: #3498db;
        }

        .nav-item.active {
            background: #3498db;
            border-left-color: #3498db;
            box-shadow: 0 4px 20px rgba(52, 152, 219, 0.3);
        }

        .nav-item.active i,
        .nav-item.active span {
            color: #ffffff;
        }

        .nav-item i {
            font-size: 1.4em;
            margin-right: 18px;
            width: 24px;
            text-align: center;
            position: relative;
            z-index: 1;
        }

        .nav-item span {
            font-weight: 500;
            position: relative;
            z-index: 1;
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.02);
            backdrop-filter: blur(20px);
            min-height: 100vh;
        }

        .content-header {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            padding: 30px 40px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .content-header h2 {
            color: #000000;
            font-size: 2.2em;
            margin-bottom: 8px;
            font-weight: 700;
        }

        .content-header p {
            color: #000000;
            font-size: 1.1em;
            font-weight: 300;
        }

        .content-body {
            flex: 1;
            padding: 40px;
            overflow-y: visible;
        }

        /* Tab Content Styles */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* 요약 카드 섹션 */
        .summary-section {
            margin-bottom: 30px;
        }
        
        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .summary-card {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        .summary-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #2196f3, #1976d2);
        }
        
        .summary-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
        }
        
        .summary-card .number {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .summary-card .label {
            color: #000000;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }
        
        .summary-card.total .number { color: #3498db; }
        .summary-card.success .number { color: #27ae60; }
        .summary-card.failure .number { color: #e74c3c; }
        .summary-card.execution .number { color: #e67e22; }
        .summary-card.interrupted .number { color: #f39c12; }
        .summary-card.not-run .number { color: #95a5a6; }
        .summary-card.rate .number { color: #9b59b6; }
        
        /* 시나리오 하위 리스트 */
        .scenario-history {
            margin-top: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .scenario-history-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            margin-bottom: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .scenario-history-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }
        
        .scenario-history-item .history-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .scenario-history-item .history-date {
            font-weight: bold;
            color: #1d80f8;
        }
        
        .scenario-history-item .history-status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
        }
        
        .scenario-history-item .history-status.pass {
            background: rgba(39, 174, 96, 0.2);
            color: #27ae60;
        }
        
        .scenario-history-item .history-status.fail {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }
        
        .scenario-history-item .history-status.stopped {
            background: rgba(243, 156, 18, 0.2);
            color: #f39c12;
        }
        
        .scenario-history-item .history-actions {
            display: flex;
            gap: 10px;
        }
        
        .scenario-history-item .btn-small {
            padding: 6px 12px;
            font-size: 0.8em;
            border-radius: 6px;
        }

        /* 시나리오 로그창 - 기존 로그탭 스타일 재사용 */
        .scenario-log-container {
            margin: 15px 0;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .log-header {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            color: white;
            padding: 20px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .log-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.1em;
            font-weight: 600;
        }

        .log-title i {
            font-size: 1.2em;
        }

        .log-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .log-close-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 8px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .log-close-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .scenario-log-container .log-content {
            padding: 25px;
            max-height: 400px;
            overflow-y: auto;
            min-height: 200px;
        }

        /* 시나리오 기록창 스타일 */
        .scenario-history-container {
            margin: 15px 0;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .history-header {
            background: linear-gradient(135deg, #1abc9c 0%, #16a085 100%);
            color: white;
            padding: 20px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.1em;
            font-weight: 600;
        }

        .history-title i {
            font-size: 1.2em;
        }

        .history-close-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 8px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .history-close-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .history-content {
            padding: 25px;
            max-height: 400px;
            overflow-y: auto;
            min-height: 200px;
            background-color: #ffffff;
            color: #000000;
        }
        
        /* 실행 로그는 검은색 배경 */
        .log-content {
            padding: 25px;
            max-height: 400px;
            overflow-y: auto;
            min-height: 200px;
            background-color: #000000 !important;
            color: #ffffff;
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            margin-bottom: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .history-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .history-info {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .history-timestamp,
        .history-status,
        .history-duration {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }

        .history-timestamp {
            color: #000000;
        }

        .history-status.success {
            color: #27ae60;
        }

        .history-status.error {
            color: #e74c3c;
        }

        .history-status.warning {
            color: #f39c12;
        }

        .history-status.info {
            color: #3498db;
        }

        .history-duration {
            color: #000000;
        }

        .history-actions {
            display: flex;
            gap: 10px;
        }

        .history-loading,
        .history-empty,
        .history-error {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 40px 20px;
            text-align: center;
            font-size: 1.1em;
        }

        .history-loading {
            color: #3498db;
        }

        .history-empty {
            color: rgba(255, 255, 255, 0.6);
        }

        .history-error {
            color: #e74c3c;
        }

        .no-report {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9em;
            font-style: italic;
        }

        /* 확인 팝업 스타일 - 컴팩트 버전 */
        .confirm-dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .confirm-dialog-overlay.show {
            opacity: 1;
        }

        .confirm-dialog {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
            transform: scale(0.9) translateY(10px);
            transition: all 0.2s ease;
            overflow: hidden;
        }

        .confirm-dialog-overlay.show .confirm-dialog {
            transform: scale(1) translateY(0);
        }

        .confirm-dialog-header {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
            padding: 16px 20px;
            text-align: center;
            position: relative;
        }

        .confirm-dialog-icon {
            font-size: 1.5em;
            margin-bottom: 8px;
            opacity: 0.9;
        }

        .confirm-dialog-header h3 {
            margin: 0;
            font-size: 1.1em;
            font-weight: 600;
        }

        .confirm-dialog-content {
            padding: 20px;
            text-align: center;
        }

        .confirm-dialog-content p {
            margin: 0 0 12px 0;
            font-size: 0.95em;
            line-height: 1.4;
            color: #333333;
        }

        .confirm-dialog-warning {
            background: rgba(231, 76, 60, 0.1);
            border: 1px solid rgba(231, 76, 60, 0.3);
            border-radius: 6px;
            padding: 8px 12px;
            margin-top: 10px;
            color: #e74c3c;
            font-size: 0.85em;
            font-weight: 500;
        }

        .confirm-dialog-actions {
            display: flex;
            gap: 10px;
            padding: 0 20px 20px 20px;
        }

        .confirm-dialog-btn {
            flex: 1;
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .confirm-dialog-cancel {
            background: #f8f9fa;
            color: #6c757d;
            border: 1px solid #dee2e6;
        }

        .confirm-dialog-cancel:hover {
            background: #e9ecef;
            transform: translateY(-1px);
        }

        .confirm-dialog-confirm {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            border: 1px solid #e74c3c;
        }

        .confirm-dialog-confirm:hover {
            background: linear-gradient(135deg, #c0392b 0%, #e74c3c 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
        }

        /* 다크 모드 확인 팝업 */
        body:not(.light-theme) .confirm-dialog {
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        body:not(.light-theme) .confirm-dialog-content p {
            color: #ffffff;
        }

        body:not(.light-theme) .confirm-dialog-cancel {
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        body:not(.light-theme) .confirm-dialog-cancel:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* 시나리오 목록 탭 */
        .scenario-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 30px;
        }

        .scenario-card {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            border: 1px solid rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: visible;
            color: #000000;
            width: 100%;
            height: auto;
            margin-bottom: 0;
        }



        .scenario-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .scenario-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 20px 40px rgba(102, 126, 234, 0.3);
            border-color: #1d80f8;
        }



        .scenario-card:hover::before {
            opacity: 1;
        }

        .scenario-card.menu-open:hover {
            transform: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .scenario-card.menu-open:hover::before {
            opacity: 0;
        }

        /* 더보기 버튼과 하위 메뉴 영역에 마우스가 있을 때 카드 hover 효과 방지 */


        .scenario-card.running {
            border-color: #f39c12;
            background: linear-gradient(135deg, rgba(243, 156, 18, 0.1) 0%, rgba(255, 193, 7, 0.1) 100%);
            box-shadow: 0 8px 32px rgba(243, 156, 18, 0.3);
        }

        .scenario-card.pass,
        .scenario-card.pass {
            border-color: #27ae60;
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.1) 0%, rgba(46, 204, 113, 0.1) 100%);
            box-shadow: 0 8px 32px rgba(39, 174, 96, 0.3);
        }

        .scenario-card.failed,
        .scenario-card.fail {
            border-color: #e74c3c;
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.1) 0%, rgba(192, 57, 43, 0.1) 100%);
            box-shadow: 0 8px 32px rgba(231, 76, 60, 0.3);
        }

        .scenario-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            position: relative;
            z-index: 1;
            gap: 15px;
        }

        .scenario-checkbox {
            position: relative;
            display: flex;
            align-items: center;
            margin-left: auto;
            z-index: 10;
        }

        /* 시나리오 상태 영역 */
        .scenario-status {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
        }

        /* 시나리오 액션 버튼들 */
        .scenario-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-left: auto;
            align-items: flex-end;
        }

        .scenario-actions-row {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .action-btn {
            min-width: 100px;
            height: 48px;
            border-radius: 24px;
            border: none;
            background: rgba(255, 255, 255, 0.08);
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.25s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            position: relative;
            overflow: hidden;
            padding: 12px 16px;
            gap: 6px;
            white-space: nowrap;
        }

        .action-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .action-btn:hover::before {
            left: 100%;
        }

        .action-btn:hover {
            transform: translateY(-2px) scale(1.1);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        /* 액션 버튼별 색상 - 현대적이고 이쁜 디자인 */
        .run-btn {
            background: linear-gradient(135deg, #10b981, #059669);
            border-color: #10b981;
        }

        .run-btn:hover {
            background: linear-gradient(135deg, #059669, #10b981);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
            transform: translateY(-1px);
        }

        .stop-btn {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border-color: #f59e0b;
        }

        .stop-btn:hover {
            background: linear-gradient(135deg, #d97706, #f59e0b);
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
            transform: translateY(-1px);
        }

        /* 실행 중일 때 중단 버튼 강조 효과 */
        .scenario-card.running .stop-btn {
            animation: pulse-orange 2s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.3;
            }
        }

        @keyframes pulse-orange {
            0% {
                box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.7);
            }
            70% {
                box-shadow: 0 0 0 8px rgba(245, 158, 11, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(245, 158, 11, 0);
            }
        }

        @keyframes pulse-red {
            0% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
                background: linear-gradient(135deg, #ef4444, #dc2626);
            }
            50% {
                box-shadow: 0 0 0 8px rgba(239, 68, 68, 0.3);
                background: linear-gradient(135deg, #dc2626, #ef4444);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
                background: linear-gradient(135deg, #ef4444, #dc2626);
            }
        }

        .settings-btn {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 50%, #374151 100%);
            border-color: #6b7280;
        }

        .settings-btn:hover {
            background: linear-gradient(135deg, #4b5563 0%, #6b7280 50%, #374151 100%);
            box-shadow: 0 6px 20px rgba(107, 114, 128, 0.5);
        }

        /* 녹화 OFF 상태 (기본) */
        .record-btn {
            background: linear-gradient(135deg, #9ca3af 0%, #6b7280 50%, #4b5563 100%);
            border-color: #9ca3af;
        }

        .record-btn:hover {
            background: linear-gradient(135deg, #6b7280 0%, #9ca3af 50%, #4b5563 100%);
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.5);
        }

        /* 녹화 ON 상태 */
        .record-btn.recording-on {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 50%, #d97706 100%);
            border-color: #fbbf24;
        }

        .record-btn.recording-on:hover {
            background: linear-gradient(135deg, #f59e0b 0%, #fbbf24 50%, #d97706 100%);
            box-shadow: 0 6px 20px rgba(251, 191, 36, 0.5);
        }

        /* 녹화중 상태 (녹화 ON + 시나리오 실행 중) */
        .record-btn.recording-active {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 50%, #b91c1c 100%);
            border-color: #ef4444;
            animation: pulse-red 2s infinite;
        }

        .record-btn.recording-active:hover {
            background: linear-gradient(135deg, #dc2626 0%, #ef4444 50%, #b91c1c 100%);
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.5);
        }



        /* 버튼 텍스트 공통 스타일 */
        .btn-text {
            font-size: 12px;
            font-weight: 600;
            color: white;
            white-space: nowrap;
        }

        /* 이력 관리 탭 버튼들 */
        .history-btn {
            background: linear-gradient(135deg, #06b6d4, #0891b2);
            border-color: #06b6d4;
        }

        .history-btn:hover {
            background: linear-gradient(135deg, #0891b2, #06b6d4);
            box-shadow: 0 4px 12px rgba(6, 182, 212, 0.4);
            transform: translateY(-1px);
        }

        .log-btn {
            background: linear-gradient(135deg, #d2b48c, #c19a6b);
            border-color: #d2b48c;
        }

        .log-btn:hover {
            background: linear-gradient(135deg, #c19a6b, #d2b48c);
            box-shadow: 0 4px 12px rgba(210, 180, 140, 0.4);
            transform: translateY(-1px);
        }

        .reset-btn {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            border-color: #9b59b6;
        }

        .reset-btn:hover {
            background: linear-gradient(135deg, #8e44ad, #9b59b6);
            box-shadow: 0 4px 12px rgba(155, 89, 182, 0.4);
            transform: translateY(-1px);
        }

        .scenario-checkbox-input {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }

        .scenario-checkbox-label {
            position: relative;
            display: inline-block;
            width: 28px;
            height: 28px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .scenario-checkbox-label:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .scenario-checkbox-input:checked + .scenario-checkbox-label {
            background: linear-gradient(135deg, #1d80f8 0%, #1565c0 100%);
            border-color: #1d80f8;
        }

        .scenario-checkbox-input:checked + .scenario-checkbox-label::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            width: 10px;
            height: 14px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: translate(-50%, -50%) rotate(45deg);
        }

        .selected-scenarios-info {
            background: rgba(102, 126, 234, 0.1) !important;
            border: 1px solid rgba(102, 126, 234, 0.3) !important;
            border-radius: 8px;
            color: #1d80f8;
            font-size: 0.9em;
            padding: 10px 15px;
            margin-bottom: 15px;
            backdrop-filter: blur(10px);
        }

        .run-selected-btn {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%) !important;
            border: none !important;
            color: white !important;
            font-weight: 600 !important;
            transition: all 0.3s ease !important;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3) !important;
        }

        .run-selected-btn:hover:not(:disabled) {
            transform: translateY(-2px) !important;
            box-shadow: 0 6px 20px rgba(39, 174, 96, 0.4) !important;
        }

        .run-selected-btn:disabled {
            background: rgba(255, 255, 255, 0.1) !important;
            color: rgba(255, 255, 255, 0.5) !important;
            cursor: not-allowed !important;
            box-shadow: none !important;
        }

        .scenario-icon {
            width: 45px;
            height: 45px;
            border-radius: 12px;
            background: #3498db;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            color: white;
            font-weight: bold;
            font-size: 1.1em;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            flex-shrink: 0;
        }

        .scenario-title {
            font-size: 1.2em;
            font-weight: 700;
            color: #000000;
            flex: 1;
        }

        .scenario-description {
            color: #000000;
            font-size: 0.95em;
            line-height: 1.5;
            margin-bottom: 15px;
            position: relative;
            z-index: 1;
        }

        .scenario-status {
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            z-index: 1;
        }

        .status-badge {
            padding: 8px 16px;
            border-radius: 25px;
            font-size: 0.85em;
            font-weight: 600;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .status-badge.ready {
            background: rgba(102, 126, 234, 0.2);
            color: #667eea;
            border-color: rgba(102, 126, 234, 0.3);
        }

        .status-badge.running {
            background: rgba(243, 156, 18, 0.2);
            color: #f39c12;
            border-color: rgba(243, 156, 18, 0.3);
        }

        .status-badge.pass,
        .status-badge.pass {
            background: rgba(39, 174, 96, 0.2);
            color: #27ae60;
            border-color: rgba(39, 174, 96, 0.3);
        }

        .status-badge.failed,
        .status-badge.fail {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
            border-color: rgba(231, 76, 60, 0.3);
        }

        .status-badge.stopped {
            background: rgba(155, 89, 182, 0.2);
            color: #9b59b6;
            border-color: rgba(155, 89, 182, 0.3);
        }

        .scenario-actions {
            margin-top: 15px;
            position: relative;
            z-index: 1;
        }

        /* 더보기 메뉴 스타일 */
        .scenario-actions-header {
            position: relative;
            display: flex;
            align-items: center;
        }





        .action-buttons {
            display: flex;
            gap: 8px;
        }

        .btn-main {
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 600;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 80px;
            justify-content: center;
        }



        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 12px;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: linear-gradient(135deg, #1d80f8 0%, #1565c0 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 255, 255, 0.1);
        }



        .log-content {
            padding: 25px;
            max-height: calc(100vh - 400px);
            overflow-y: auto;
            min-height: 600px;
        }

        .log-entry {
            padding: 15px;
            margin-bottom: 12px;
            border-radius: 12px;
            font-family: 'JetBrains Mono', 'Fira Code', 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.5;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .log-entry:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .log-entry.info {
            background: rgba(102, 126, 234, 0.1);
            color: #1d80f8;
            border-left: 4px solid #1d80f8;
        }

        .log-entry.success {
            background: rgba(39, 174, 96, 0.1);
            color: #27ae60;
            border-left: 4px solid #27ae60;
        }

        .log-entry.warning {
            background: rgba(243, 156, 18, 0.1);
            color: #f39c12;
            border-left: 4px solid #f39c12;
        }

        .log-entry.error {
            background: rgba(231, 76, 60, 0.1);
            color: #e74c3c;
            border-left: 4px solid #e74c3c;
        }

        .log-timestamp {
            font-weight: bold;
            margin-right: 10px;
        }

        /* 레포트 탭 */
        .report-container {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            height: calc(100vh - 100px);
            min-height: 1200px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .report-header {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
            padding: 25px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .report-header h3 {
            font-size: 1.4em;
            font-weight: 700;
        }

        .report-content {
            height: calc(100% - 90px);
            padding: 25px;
            min-height: 1100px;
        }

        .report-frame {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 12px;
            background: #ffffff;
            min-height: 750px;
        }

        /* 설정 탭 */
        .settings-container {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 40px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .settings-section {
            margin-bottom: 35px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(10px);
        }

        .settings-section h3 {
            color: #1d80f8;
            margin-bottom: 20px;
            font-size: 1.3em;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.95em;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.05);
            color: #ffffff;
            backdrop-filter: blur(10px);
        }

        /* 사용자 목록 스타일 */
        .user-row {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .user-row-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .user-row-header h4 {
            color: #1d80f8;
            font-size: 1.1em;
            font-weight: 600;
            margin: 0;
        }

        .btn-sm {
            padding: 8px 16px;
            font-size: 0.85em;
            border-radius: 8px;
        }

        .btn-danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            border: none;
            color: white;
            transition: all 0.3s ease;
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, #c0392b 0%, #a93226 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
        }

        .section-description {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9em;
            margin-bottom: 20px;
            font-style: italic;
        }

        .form-actions {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #1d80f8;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
            background: rgba(255, 255, 255, 0.1);
        }

        .form-group input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .form-group select option {
            background: #1a1a2e;
            color: #ffffff;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
        }

        .settings-actions {
            display: flex;
            gap: 20px;
            margin-top: 30px;
            justify-content: center;
        }

        .settings-status {
            text-align: center;
            margin-top: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            font-style: italic;
            padding: 15px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
        }

        /* 도움말 탭 */
        .help-container {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 40px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .help-section {
            margin-bottom: 45px;
        }

        .help-section h3 {
            color: #1d80f8;
            font-size: 1.5em;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #1d80f8;
            font-weight: 700;
        }

        .help-content {
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.7;
        }

        .help-content p {
            margin-bottom: 18px;
        }

        .help-content ul {
            margin-left: 25px;
            margin-bottom: 18px;
        }

        .help-content li {
            margin-bottom: 10px;
        }

        .help-content code {
            background: rgba(102, 126, 234, 0.1);
            padding: 4px 8px;
            border-radius: 6px;
            font-family: 'JetBrains Mono', 'Fira Code', 'Courier New', monospace;
            color: #1d80f8;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .help-content .highlight {
            background: rgba(243, 156, 18, 0.1);
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid #f39c12;
            margin: 20px 0;
            backdrop-filter: blur(10px);
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid #1d80f8;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: #3498db;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #2980b9;
        }

        /* Touch-friendly interactions */
        @media (hover: none) and (pointer: coarse) {
            .nav-item,
            .scenario-card,
            .btn {
                min-height: 44px;
            }
            
            .nav-item {
                padding: 15px 20px;
            }
            
            .btn {
                padding: 15px 24px;
            }
            
            .scenario-card {
                padding: 25px;
            }
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            margin: 0;
            padding: 0;
            border-radius: 20px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
        }

        /* 모달 내부 스크롤바 스타일링 */
        .modal-content::-webkit-scrollbar {
            width: 8px;
        }

        .modal-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .modal-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        .modal-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .modal-header {
            background: linear-gradient(135deg, #1d80f8 0%, #1565c0 100%);
            color: white;
            padding: 25px 30px;
            border-radius: 20px 20px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.5em;
            font-weight: 700;
        }

        .close {
            color: white;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .close:hover {
            transform: scale(1.2);
        }

        .modal-body {
            padding: 30px;
        }

        .scenario-info {
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .scenario-info h3 {
            color: #1d80f8;
            margin-bottom: 10px;
            font-size: 1.3em;
            font-weight: 700;
        }

        .scenario-info p {
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.6;
        }

        .modal-actions {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%) !important;
            color: white !important;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
        }

        .btn-success:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(39, 174, 96, 0.4);
        }

        .btn-success:disabled {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%) !important;
            color: white !important;
        }

        .btn-info {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%) !important;
            color: white !important;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        .btn-info:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.4);
        }

        .btn-info:disabled {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%) !important;
            color: white !important;
        }

        .btn-recording {
            background: linear-gradient(135deg, #6c757d, #5a6268) !important;
            color: white !important;
            border: none;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(108, 117, 125, 0.3);
        }

        .btn-recording:hover {
            background: linear-gradient(135deg, #5a6268, #495057) !important;
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(108, 117, 125, 0.4);
        }

        .btn-recording.active {
            background: linear-gradient(135deg, #dc3545, #c82333) !important;
            animation: recording-pulse 2s infinite;
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.4);
        }

        .btn-recording.active:hover {
            background: linear-gradient(135deg, #c82333, #bd2130) !important;
            box-shadow: 0 8px 25px rgba(220, 53, 69, 0.5);
        }

        @keyframes recording-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* 모달 내 녹화 설정 옵션 카드 */
        .recording-options {
            display: grid;
            gap: 15px;
            margin-top: 20px;
        }

        .recording-option {
            display: flex;
            align-items: center;
            padding: 20px;
            border: 2px solid #e1e8ed;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
            position: relative;
            overflow: hidden;
        }

        .recording-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }

        .recording-option.selected {
            border-color: #1d80f8;
            background: linear-gradient(135deg, #f8f9ff 0%, #f0f2ff 100%);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.2);
        }

        .recording-option.selected::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(135deg, #1d80f8 0%, #1565c0 100%);
        }

        .recording-icon {
            width: 60px;
            height: 60px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 20px;
            flex-shrink: 0;
            background: #f8f9fa;
            color: #6c757d;
            font-size: 1.5em;
            transition: all 0.3s ease;
        }

        .recording-option.selected .recording-icon {
            background: linear-gradient(135deg, #1d80f8 0%, #1565c0 100%);
            color: white;
            transform: scale(1.1);
        }

        .recording-content {
            flex: 1;
        }

        .recording-content h4 {
            margin: 0 0 8px 0;
            color: #2c3e50;
            font-size: 1.2em;
            font-weight: 600;
        }

        .recording-content p {
            margin: 0 0 12px 0;
            color: #666;
            font-size: 0.95em;
            line-height: 1.4;
        }

        .recording-benefits {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .benefit-tag {
            padding: 4px 8px;
            background: #e9ecef;
            color: #495057;
            border-radius: 12px;
        }

        /* 녹화 폴더 설정 스타일 */
        .recording-folder-section {
            margin-top: 15px;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(102, 126, 234, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(102, 126, 234, 0.2);
            backdrop-filter: blur(10px);
        }

        .recording-folder-section h4 {
            margin: 0 0 15px 0;
            color: #1d80f8;
            font-size: 1.1em;
            font-weight: 600;
        }

        .folder-path-input {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .folder-path-input input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid rgba(102, 126, 234, 0.3);
            border-radius: 8px;
            font-size: 0.95em;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            cursor: default;
        }

        .folder-path-input input:focus {
            outline: none;
            border-color: #1d80f8;
        }

        .folder-path-input button {
            padding: 12px 16px;
            background: #1d80f8;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .folder-path-input button:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .folder-help {
            margin: 0;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9em;
            line-height: 1.4;
        }

        .info-box {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }

        .info-box i {
            color: #3b82f6;
            font-size: 16px;
            margin-top: 2px;
        }

        .info-box p {
            color: #3b82f6;
            font-size: 14px;
            margin: 0;
            line-height: 1.4;
        }

        .recording-option.selected .benefit-tag {
            background: rgba(102, 126, 234, 0.1);
            color: #1d80f8;
        }

        .recording-status {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #e9ecef;
            color: #6c757d;
            margin-left: 15px;
            flex-shrink: 0;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .recording-option.selected .recording-status {
            background: #28a745;
            color: white;
            opacity: 1;
            transform: scale(1.1);
        }

        .recording-status i {
            font-size: 0.9em;
        }

        /* 알림 시스템 스타일 */
        .notification {
            position: fixed;
            top: 30px;
            right: 30px;
            padding: 25px 30px;
            border-radius: 16px;
            color: white;
            font-weight: 600;
            font-size: 0.95em;
            z-index: 10001;
            max-width: 450px;
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
            transform: translateX(100%) scale(0.9);
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            opacity: 0;
        }

        .notification.show {
            transform: translateX(0) scale(1);
            opacity: 1;
        }

        .notification.success {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            border-left: 4px solid #1e8449;
        }

        .notification.error {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            border-left: 4px solid #a93226;
        }

        .notification.warning {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            border-left: 4px solid #d68910;
        }

        .notification.info {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            border-left: 4px solid #21618c;
        }

        .notification-title {
            font-size: 1.2em;
            font-weight: 700;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .notification-message {
            font-size: 0.95em;
            opacity: 0.95;
            line-height: 1.5;
        }

        .notification-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .notification-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        /* Expandable Section Styles */
        .expandable-section {
            margin-bottom: 20px;
            border-radius: 15px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .expandable-header {
            background: linear-gradient(135deg, #1d80f8 0%, #1565c0 100%);
            color: white;
            padding: 20px 25px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .expandable-header:hover {
            background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
        }

        .expandable-header h3 {
            margin: 0;
            font-size: 1.2em;
            font-weight: 600;
        }

        .expandable-icon {
            font-size: 1.5em;
            transition: transform 0.3s ease;
        }

        .expandable-section.expanded .expandable-icon {
            transform: rotate(180deg);
        }

        .expandable-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            background: rgba(255, 255, 255, 0.03);
        }

        .expandable-section.expanded .expandable-content {
            max-height: 3000px;
        }

        .expandable-content-inner {
            padding: 25px;
        }

        /* Expandable section 내부의 레포트 콘텐츠 높이 조정 */
        .expandable-section .report-content {
            min-height: 800px;
            height: 800px;
        }

        .expandable-section .log-content {
            min-height: 600px;
            max-height: 800px;
        }

        /* Floating Particles Animation */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(102, 126, 234, 0.3);
            border-radius: 50%;
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px) rotate(0deg);
                opacity: 0;
            }
            50% {
                transform: translateY(-20px) rotate(180deg);
                opacity: 1;
            }
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .scenario-grid {
                gap: 18px;
            }
            
            .content-body {
                padding: 30px;
            }
            
            .content-header {
                padding: 25px 30px;
            }
            
            .content-header h2 {
                font-size: 1.8em;
            }
        }

        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
            }
            
            .lnb {
                width: 100%;
                height: auto;
                flex-direction: row;
                padding: 10px;
            }
            
            .lnb-header {
                padding: 15px;
                border-bottom: none;
                border-right: 1px solid rgba(255,255,255,0.1);
                width: auto;
                height: auto;
            }
            
            .lnb-header h1 {
                font-size: 1.2em;
                margin-bottom: 0;
            }
            
            .lnb-header p {
                display: none;
            }
            
            .lnb-nav {
                flex: 1;
                display: flex;
                flex-direction: row;
                padding: 0;
                overflow-x: auto;
            }
            
            .nav-item {
                flex-shrink: 0;
                padding: 12px 20px;
                margin: 0 5px;
                border-left: none;
                border-bottom: 3px solid transparent;
                min-width: 120px;
                text-align: center;
            }
            
            .nav-item i {
                margin-right: 8px;
                font-size: 1.2em;
            }
            
            .nav-item span {
                font-size: 0.9em;
            }
            
            .nav-item.active {
                border-bottom-color: #1d80f8;
            }
            
            .main-content {
                flex: 1;
                min-height: calc(100vh - 80px);
            }
            
            .content-header {
                padding: 20px;
                height: auto;
            }
            
            .content-header h2 {
                font-size: 1.5em;
            }
            
            .content-header p {
                font-size: 1em;
            }
            
            .content-body {
                padding: 20px;
            }
            
            .scenario-grid {
                gap: 15px;
            }
            
            .scenario-card {
                padding: 20px;
            }
            
            .scenario-header {
                flex-direction: column;
                text-align: center;
                gap: 10px;
            }
            
            .scenario-icon {
                margin-right: 0;
                margin-bottom: 10px;
            }
            
            .scenario-actions {
                flex-direction: column;
                gap: 10px;
            }
            
            .btn {
                width: 100%;
                padding: 15px;
            }
            
            .form-row {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .settings-actions {
                flex-direction: column;
                gap: 15px;
            }
            
            .log-container,
            .report-container,
            .settings-container,
            .help-container {
                margin: 0 -10px;
                border-radius: 15px;
            }
            
            .log-header,
            .report-header {
                padding: 20px;
            }
            
            .log-content,
            .report-content {
                padding: 20px;
            }
        }

        @media (max-width: 480px) {
            .lnb {
                padding: 8px;
            }
            
            .lnb-header {
                padding: 10px;
            }
            
            .lnb-header h1 {
                font-size: 1em;
            }
            
            .nav-item {
                padding: 10px 15px;
                min-width: 100px;
            }
            
            .nav-item i {
                font-size: 1em;
                margin-right: 5px;
            }
            
            .nav-item span {
                font-size: 0.8em;
            }
            
            .content-header {
                padding: 15px;
            }
            
            .content-header h2 {
                font-size: 1.3em;
            }
            
            .content-body {
                padding: 15px;
            }
            
            .scenario-card {
                padding: 15px;
            }
            
            .scenario-title {
                font-size: 1.1em;
            }
            
            .scenario-description {
                font-size: 0.9em;
            }
            
            .btn {
                padding: 12px;
                font-size: 0.9em;
            }
            
            .log-container,
            .report-container,
            .settings-container,
            .help-container {
                padding: 20px;
            }
            
            .settings-section {
                padding: 15px;
            }
            
            .form-group input,
            .form-group select {
                padding: 12px;
            }
        }

        /* Landscape orientation for mobile */
        @media (max-width: 768px) and (orientation: landscape) {
            .lnb {
                height: 60px;
            }
            
            .main-content {
                min-height: calc(100vh - 60px);
            }
            
            .nav-item {
                padding: 8px 15px;
            }
            
            .nav-item span {
                display: none;
            }
        }

        /* Toast 알림 스타일 */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toast {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 16px 20px;
            min-width: 300px;
            max-width: 400px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transform: translateX(100%);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 500;
        }

        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }

        .toast.hide {
            transform: translateX(100%);
            opacity: 0;
        }

        .toast-icon {
            font-size: 1.2em;
            flex-shrink: 0;
        }

        .toast-content {
            flex: 1;
            color: #333;
        }

        .toast-title {
            font-weight: 600;
            margin-bottom: 4px;
            font-size: 0.95em;
        }

        .toast-message {
            font-size: 0.9em;
            opacity: 0.8;
            line-height: 1.4;
        }

        .toast-close {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 1.1em;
        }

        .toast-close:hover {
            background: rgba(0, 0, 0, 0.1);
            color: #333;
        }

        /* Toast 타입별 스타일 */
        .toast.success {
            border-left: 4px solid #10b981;
        }

        .toast.success .toast-icon {
            color: #10b981;
        }

        .toast.error {
            border-left: 4px solid #ef4444;
        }

        .toast.error .toast-icon {
            color: #ef4444;
        }

        .toast.warning {
            border-left: 4px solid #f59e0b;
        }

        .toast.warning .toast-icon {
            color: #f59e0b;
        }

        .toast.info {
            border-left: 4px solid #3b82f6;
        }

        .toast.info .toast-icon {
            color: #3b82f6;
        }

        /* ============================================================================ */
        /* 테스트 유형 선택 화면 스타일 */
        /* ============================================================================ */
        .test-type-selection-screen {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            min-height: 100vh;
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 50%, #90caf9 100%);
            padding: 40px;
        }

        body.light-theme .test-type-selection-screen {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 50%, #90caf9 100%);
        }

        .test-type-selection-screen.hidden {
            display: none;
        }

        .test-type-container {
            max-width: 900px;
            width: 100%;
        }

        .test-type-header {
            text-align: center;
            margin-bottom: 48px;
        }

        .test-type-title {
            font-size: 36px;
            font-weight: 700;
            color: #000000;
            margin-bottom: 12px;
        }

        body.light-theme .test-type-title {
            color: #2c3e50;
        }

        .test-type-subtitle {
            font-size: 18px;
            color: rgba(0, 0, 0, 0.7);
            font-weight: 400;
        }

        body.light-theme .test-type-subtitle {
            color: #7f8c8d;
        }

        .test-type-subtitle span {
            font-weight: 700;
            color: #1d80f8;
        }

        body.light-theme .test-type-subtitle span {
            color: #1d80f8;
        }

        .test-type-cards {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 32px;
        }

        .test-type-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 20px;
            padding: 48px 32px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }

        body.light-theme .test-type-card {
            background: white;
            border-color: #e9ecef;
        }

        .test-type-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: #1d80f8;
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.3s ease;
        }

        body.light-theme .test-type-card::before {
            background: #1d80f8;
        }

        .test-type-card:hover::before {
            transform: scaleX(1);
        }

        .test-type-card:hover {
            border-color: #1d80f8;
            transform: translateY(-8px);
            box-shadow: 0 16px 32px rgba(29, 128, 248, 0.2);
        }

        body.light-theme .test-type-card:hover {
            border-color: #1d80f8;
            box-shadow: 0 16px 32px rgba(29, 128, 248, 0.2);
        }

        .test-type-icon {
            font-size: 72px;
            margin-bottom: 24px;
        }

        .test-type-name {
            font-size: 24px;
            font-weight: 700;
            color: #000000;
            margin-bottom: 12px;
        }

        body.light-theme .test-type-name {
            color: #2c3e50;
        }

        .test-type-desc {
            font-size: 15px;
            color: rgba(0, 0, 0, 0.6);
            line-height: 1.6;
            margin-bottom: 20px;
        }

        body.light-theme .test-type-desc {
            color: #7f8c8d;
        }

        .test-type-status {
            display: inline-block;
            padding: 6px 16px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.3px;
        }

        .test-type-status.available {
            background: #e8f5e9;
            color: #2e7d32;
        }

        body.light-theme .test-type-status.available {
            background: #d4edda;
            color: #155724;
        }

        .test-type-status.coming-soon {
            background: #fff3e0;
            color: #e65100;
        }

        body.light-theme .test-type-status.coming-soon {
            background: #fff8e1;
            color: #f57c00;
        }

        /* 메인 앱 컨텐츠 래퍼 */
        .main-app-content {
            display: flex;
            flex: 1;
        }

        /* 반응형 */
        @media (max-width: 768px) {
            .test-type-cards {
                grid-template-columns: 1fr;
                gap: 24px;
            }
            
            .test-type-title {
                font-size: 28px;
            }

            .test-type-card {
                padding: 32px 24px;
            }

            .test-type-icon {
                font-size: 56px;
            }
        }
    </style>
</head>
<body>
    <!-- Toast 알림 컨테이너 -->
    <div class="toast-container" id="toastContainer"></div>
    
    <!-- Floating Particles -->
    <div class="particles" id="particles"></div>
    
    <button class="back-button" onclick="goBackToProductSelector()">
        <i class="fas fa-arrow-left"></i>
        뒤로
    </button>
    
    <div class="app-container">
        <!-- 테스트 유형 선택 화면 -->
        <div id="testTypeSelectionScreen" class="test-type-selection-screen">
            <div class="test-type-container">
                <div class="test-type-header">
                    <h2 class="test-type-title">테스트 유형 선택</h2>
                    <p class="test-type-subtitle"><span id="currentProductName">CMP</span> 테스트를 시작합니다</p>
                </div>
                
                <div class="test-type-cards">
                    <div class="test-type-card" onclick="selectTestType('api')">
                        <div class="test-type-icon">🧪</div>
                        <h3 class="test-type-name">API 테스트</h3>
                        <p class="test-type-desc">SwaggerUI JSON 기반 REST API 테스트</p>
                        <span class="test-type-status coming-soon">Coming Soon</span>
                    </div>
                    
                    <div class="test-type-card" onclick="selectTestType('ui')">
                        <div class="test-type-icon">🖥️</div>
                        <h3 class="test-type-name">UI 테스트</h3>
                        <p class="test-type-desc">Playwright 기반 UI 자동화 테스트</p>
                        <span class="test-type-status available">사용 가능</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- 메인 앱 컨텐츠 (LNB + Main Content) -->
        <div id="mainAppContent" class="main-app-content" style="display: none;">
            <!-- LNB (Left Navigation Bar) -->
            <div class="lnb">
        <div class="lnb-header">
            <h1>
                <img src="../COMMON/images/cmp_24x24.png" alt="logo" width="24" height="24">
                CMP
            </h1>
            <p>자동화 테스트</p>
        </div>
            
            <div class="lnb-nav">
                <div class="nav-item active" onclick="switchTab('scenarios', event)">
                    <i>📋</i>
                    <span>시나리오 목록</span>
                </div>
                <div class="nav-item" onclick="switchTab('history', event)">
                    <i>📊</i>
                    <span>이력 관리</span>
                </div>
                <div class="nav-item" onclick="navigateToCodegen(event)">
                    <i>🎬</i>
                    <span>코드 생성</span>
                </div>
            </div>
            
            <div class="theme-toggle">
                <button id="themeToggle" class="theme-toggle-btn" onclick="toggleTheme()" title="테마 변경">
                    <i class="fas fa-moon" id="themeIcon"></i>
                </button>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="main-content">
            <!-- 시나리오 목록 탭 -->
            <div id="scenarios" class="tab-content active">
                <div class="content-header">
                    <h2>📋 시나리오 목록</h2>
                    <p style="color: #000000;">테스트 시나리오를 관리하고 실행할 수 있습니다.</p>
                </div>
                <div class="content-body">
                    <!-- 요약 카드 섹션 -->
                    <div class="summary-section">
                        <div class="summary-cards" id="summaryCards">
                            <!-- 요약 카드들이 동적으로 생성됩니다 -->
                        </div>
                    </div>
                    
                    <!-- 시나리오 그리드 -->
                    <div class="scenario-grid" id="scenarioGrid">
                        <!-- 시나리오 카드들이 동적으로 생성됩니다 -->
                    </div>
                </div>
            </div>

            <!-- 이력 관리 탭 -->
            <div id="history" class="tab-content">
                <div class="content-header">
                    <h2>📊 이력 관리</h2>
                    <p>시나리오 실행 기록과 로그를 확인할 수 있습니다.</p>
                </div>
                <div class="content-body">
                    <!-- 요약 카드 섹션 -->
                    <div class="summary-section">
                        <div class="summary-cards" id="historySummaryCards">
                            <!-- 요약 카드들이 동적으로 생성됩니다 -->
                            </div>
                        </div>
                        
                    <!-- 시나리오 그리드 -->
                    <div class="scenario-grid" id="historyScenarioGrid">
                        <!-- 시나리오 카드들이 동적으로 생성됩니다 -->
                    </div>
                </div>
            </div>

        </div>
    </div>

    <!-- 시나리오 설정 모달 -->
    <div id="scenarioModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">시나리오 설정</h2>
                <span class="close" onclick="closeScenarioModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="scenario-info">
                    <h3 id="scenarioTitle">시나리오 제목</h3>
                    <p id="scenarioDescription">시나리오 설명</p>
                </div>
                
                <form id="scenarioSettingsForm">
                    <!-- 로그인 설정 -->
                    <div class="settings-section">
                        <h3>🔐 로그인 설정</h3>
                        <div class="form-row">
                            <div class="form-group">
                                <label for="modalUserId">사용자 ID</label>
                                <input type="text" id="modalUserId" name="userId" required style="background-color: #ffffff; color: #333;">
                            </div>
                            <div class="form-group">
                                <label for="modalPassword">비밀번호</label>
                                <input type="password" id="modalPassword" name="password" required style="background-color: #ffffff; color: #333;">
                            </div>
                        </div>
                    </div>

                    <!-- 프로젝트 설정 -->
                    <div class="settings-section">
                        <h3>📋 프로젝트 설정</h3>
                        <div class="form-row">
                            <div class="form-group">
                                <label for="modalProjectCode">업무코드</label>
                                <input type="text" id="modalProjectCode" name="projectCode" required readonly style="background-color: #f5f5f5 !important; color: #666 !important;">
                            </div>
                            <div class="form-group">
                                <label for="modalProjectName">프로젝트 이름</label>
                                <input type="text" id="modalProjectName" name="projectName" required readonly style="background-color: #f5f5f5 !important; color: #666 !important;">
                            </div>
                        </div>
                    </div>

                    <!-- 저장소 설정 -->
                    <div class="settings-section">
                        <h3>📁 저장소 설정</h3>
                        <div class="form-row">
                            <div class="form-group">
                                <label for="modalRepositoryName">저장소 이름</label>
                                <input type="text" id="modalRepositoryName" name="repositoryName" required readonly style="background-color: #f5f5f5 !important; color: #666 !important;">
                            </div>
                        </div>
                    </div>

                    <!-- 사용자 설정 (주석처리됨) -->
                    <!--
                    <div class="settings-section">
                        <h3>👤 사용자 설정</h3>
                        <div class="form-row">
                            <div class="form-group">
                                <label for="modalUserName">사용자 이름</label>
                                <input type="text" id="modalUserName" name="userName" required>
                            </div>
                            <div class="form-group">
                                <label for="modalUserEmail">사용자 이메일</label>
                                <input type="email" id="modalUserEmail" name="userEmail" required>
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label for="modalUserLevel">사용자 레벨</label>
                                <select id="modalUserLevel" name="userLevel" required>
                                    <option value="주니어(01)">주니어(01)</option>
                                    <option value="주임(02)">주임(02)</option>
                                    <option value="대리(03)">대리(03)</option>
                                    <option value="과장(04)">과장(04)</option>
                                    <option value="차장(05)">차장(05)</option>
                                    <option value="부장(06)">부장(06)</option>
                                    <option value="이사(07)">이사(07)</option>
                                    <option value="상무(08)">상무(08)</option>
                                    <option value="전무(09)">전무(09)</option>
                                    <option value="부사장(10)">부사장(10)</option>
                                    <option value="사장(11)">사장(11)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="modalUserRole">사용자 역할</label>
                                <select id="modalUserRole" name="userRole" required>
                                    <option value="빌드배포 관리자">빌드배포 관리자</option>
                                    <option value="포털 관리자">포털 관리자</option>
                                    <option value="결재자">결재자</option>
                                    <option value="개발 리더">개발 리더</option>
                                    <option value="테스트 담당자">테스트 담당자</option>
                                    <option value="개발자">개발자</option>
                                </select>
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label for="modalSystemRole">시스템 역할</label>
                                <select id="modalSystemRole" name="systemRole" required>
                                    <option value="시스템관리자(사용자)">시스템관리자(사용자)</option>
                                    <option value="솔루션분석팀">솔루션분석팀</option>
                                    <option value="라이프사이클">라이프사이클</option>
                                    <option value="티켓(view)">티켓(view)</option>
                                    <option value="BQA">BQA</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    -->

                    <!-- 사용자 목록 설정 -->
                    <div class="settings-section">
                        <h3>👥 사용자 목록 설정</h3>
                        <p class="section-description">업무 코드 할당을 위한 사용자 목록을 설정합니다.</p>
                        
                        <div id="usersList">
                            <!-- 사용자 항목들이 여기에 동적으로 추가됩니다 -->
                        </div>
                        
                        <div class="form-actions">
                            <button type="button" class="btn btn-secondary" onclick="addUserRow()">+ 사용자 추가</button>
                        </div>
                    </div>

                    <!-- 녹화 설정 -->
                    <div class="settings-section">
                        <h3>📹 화면 녹화 설정</h3>
                        <p class="section-description">테스트 실행 중 화면 녹화 여부와 저장 경로를 설정합니다.</p>
                        
                        <div class="recording-options">
                            <div class="recording-option" id="recording-enabled-option">
                                <div class="recording-icon">
                                    <i class="fas fa-video"></i>
                                </div>
                                <div class="recording-content">
                                    <h4>화면 녹화 활성화</h4>
                                    <p>테스트 실행 과정을 비디오로 녹화하여 지정된 폴더에 저장합니다.</p>
                                    <div class="recording-benefits">
                                        <span class="benefit-tag">실행 과정 기록</span>
                                        <span class="benefit-tag">문제 분석 용이</span>
                                        <span class="benefit-tag">독립적 파일 저장</span>
                                    </div>
                                </div>
                                <div class="recording-status">
                                    <i class="fas fa-check"></i>
                                </div>
                            </div>
                            
                            <!-- 녹화 폴더 경로 설정 (활성화 옵션과 비활성화 옵션 사이) -->
                            <div class="recording-folder-section" id="recordingFolderSection" style="display: none;">
                                <h4>📁 녹화 파일 저장 경로</h4>
                                <div class="folder-path-input">
                                    <input type="text" id="recordingFolderPath" placeholder="녹화 파일을 저장할 폴더 경로를 선택하세요" readonly>
                                    <button type="button" class="btn btn-secondary" onclick="selectRecordingFolder()">
                                        <i class="fas fa-folder-open"></i> 폴더 선택
                                    </button>
                                </div>
                                <p class="folder-help">선택된 폴더에 녹화 파일이 저장됩니다. 폴더가 존재하지 않으면 자동으로 생성됩니다.</p>
                            </div>
                            
                            <div class="recording-option" id="recording-disabled-option">
                                <div class="recording-icon">
                                    <i class="fas fa-video-slash"></i>
                                </div>
                                <div class="recording-content">
                                    <h4>화면 녹화 비활성화</h4>
                                    <p>화면 녹화 없이 테스트를 실행하여 성능을 최적화합니다.</p>
                                    <div class="recording-benefits">
                                        <span class="benefit-tag">빠른 실행</span>
                                        <span class="benefit-tag">저장 공간 절약</span>
                                        <span class="benefit-tag">리소스 효율성</span>
                                    </div>
                                </div>
                                <div class="recording-status">
                                    <i class="fas fa-check"></i>
                                </div>
                            </div>
                        </div>
                        
                        <input type="hidden" id="modalRecordingEnabled" value="false">
                        <input type="hidden" id="modalRecordingFolder" value="">
                    </div>

                    <div class="modal-actions">
                        <button type="button" class="btn btn-secondary" onclick="closeScenarioModal()">닫기</button>
                        <button type="button" class="btn btn-primary" onclick="saveScenarioSettings()">설정 저장</button>
                        <button type="button" class="btn btn-success" onclick="runScenarioWithSettings()">실행</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

        </div> <!-- End mainAppContent -->
    </div> <!-- End app-container -->

    <!-- 녹화 설정 전용 모달 -->
    <div id="recordingModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>📹 녹화 설정</h2>
                <span class="close" onclick="closeRecordingModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="scenario-info">
                    <h3 id="recordingModalTitle">시나리오 제목</h3>
                    <p id="recordingModalDescription">시나리오 설명</p>
                </div>
                
                <!-- 녹화 설정 -->
                <div class="settings-section">
                    <h3>📹 화면 녹화 설정</h3>
                    <p class="section-description">테스트 실행 중 화면 녹화 여부와 저장 경로를 설정합니다.</p>
                    
                    <div class="recording-options">
                        <div class="recording-option" id="recording-modal-enabled-option">
                            <div class="recording-icon">
                                <i class="fas fa-video"></i>
                            </div>
                            <div class="recording-content">
                                <h4>화면 녹화 활성화</h4>
                                <p>테스트 실행 과정을 비디오로 녹화하여 지정된 폴더에 저장합니다.</p>
                                <div class="recording-benefits">
                                    <span class="benefit-tag">실행 과정 기록</span>
                                    <span class="benefit-tag">문제 분석 용이</span>
                                    <span class="benefit-tag">독립적 파일 저장</span>
                                </div>
                            </div>
                            <div class="recording-status">
                                <i class="fas fa-check"></i>
                            </div>
                        </div>
                        
                        <!-- 녹화 폴더 경로 설정 (활성화 옵션 바로 아래) -->
                        <div class="recording-folder-section" id="recordingModalFolderSection" style="display: none;">
                            <h4>📁 녹화 파일 저장 경로</h4>
                            <div class="folder-path-input">
                                <input type="text" id="recordingModalFolderPath" placeholder="녹화 파일을 저장할 폴더 경로를 선택하세요" readonly>
                                <button type="button" class="btn btn-secondary" onclick="selectRecordingModalFolder()">
                                    <i class="fas fa-folder-open"></i> 폴더 선택
                                </button>
                            </div>
                            <p class="folder-help">선택된 폴더에 녹화 파일이 저장됩니다. 폴더가 존재하지 않으면 자동으로 생성됩니다.</p>
                        </div>
                        
                        <div class="recording-option" id="recording-modal-disabled-option">
                            <div class="recording-icon">
                                <i class="fas fa-video-slash"></i>
                            </div>
                            <div class="recording-content">
                                <h4>화면 녹화 비활성화</h4>
                                <p>화면 녹화 없이 테스트를 실행하여 성능을 최적화합니다.</p>
                                <div class="recording-benefits">
                                    <span class="benefit-tag">빠른 실행</span>
                                    <span class="benefit-tag">저장 공간 절약</span>
                                    <span class="benefit-tag">리소스 효율성</span>
                                </div>
                            </div>
                            <div class="recording-status">
                                <i class="fas fa-check"></i>
                            </div>
                        </div>
                    </div>
                    
                    <input type="hidden" id="recordingModalEnabled" value="false">
                    <input type="hidden" id="recordingModalFolder" value="">
                </div>

                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeRecordingModal()">닫기</button>
                    <button type="button" class="btn btn-primary" onclick="saveRecordingSettings()">설정 저장</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');

        // 시나리오 데이터
        // 시나리오 데이터 (scenario-list.json에서 로드됨)
        let scenarios = [];
        
        // 시나리오 로드 함수
        async function loadScenarios() {
            try {
                console.log(`📋 CMP 시나리오 로드 시작`);
                
                // 기본 시나리오 데이터
                // scenario-list.json에서 시나리오 로드
                try {
                    const response = await fetch('./custom-reports/scenario-list.json');
                    if (response.ok) {
                        const data = await response.json();
                        console.log('📋 scenario-list.json 로드 성공:', data);
                        
                        // scenario-list.json의 모든 시나리오를 UI 형식으로 변환
                        scenarios = data.scenarios
                            .filter(s => true) // 모든 시나리오 로드
                            .map(s => ({
                                id: s.id,
                                title: s.name.replace(/^시나리오 \d+:\s*/, ''), // "시나리오 3: test11" -> "test11"
                                description: s.description || `시나리오 ${s.id}`,
                                status: s.status === 'not-run' ? 'ready' : s.status,
                                lastRun: s.lastRun,
                                duration: s.duration,
                                runCount: s.runCount || 0
                            }));
                        
                        console.log(`📋 CMP 시나리오 로드 완료: ${scenarios.length}개`, scenarios.map(s => ({ id: s.id, title: s.title, status: s.status })));
                    } else {
                        // scenario-list.json이 없으면 빈 배열 사용
                        console.warn('📋 scenario-list.json 없음, 빈 시나리오 목록 사용');
                        scenarios = [];
                    }
                } catch (jsonError) {
                    console.warn('📋 scenario-list.json 로드 실패, 빈 시나리오 목록 사용:', jsonError.message);
                    scenarios = [];
                }
                
                console.log(`📋 CMP 시나리오 로드 완료: ${scenarios.length}개`);
                
                // 시나리오 개수 표시 업데이트
                const countEl = document.getElementById('scenarioCountDesc');
                if (countEl) {
                    if (scenarios.length === 0) {
                        countEl.textContent = `등록된 시나리오가 없습니다. 새로운 시나리오를 생성해보세요.`;
                    } else {
                        countEl.textContent = `총 ${scenarios.length}개의 테스트 시나리오를 관리하고 실행할 수 있습니다.`;
                    }
                }
                
            } catch (error) {
                console.error('시나리오 로드 중 오류:', error);
                scenarios = [];
                const countEl = document.getElementById('scenarioCountDesc');
                if (countEl) countEl.textContent = `등록된 시나리오가 없습니다. 새로운 시나리오를 생성해보세요.`;
            }
        }

        // 페이지 로드 시 초기화
        document.addEventListener('DOMContentLoaded', () => {
            console.log('🟢 애플리케이션 초기화 시작');
            
            // ⭐ 초기 화면 설정: 테스트 유형 선택 화면 표시, 메인 앱 숨김
            const testTypeScreen = document.getElementById('testTypeSelectionScreen');
            const mainAppContent = document.getElementById('mainAppContent');
            
            if (testTypeScreen) {
                testTypeScreen.classList.remove('hidden');
                console.log('✅ 테스트 유형 선택 화면 표시');
            }
            
            if (mainAppContent) {
                mainAppContent.style.display = 'none';
                console.log('✅ 메인 앱 컨텐츠 숨김');
            }
            
            // 제품명 표시
            const productNameEl = document.getElementById('currentProductName');
            if (productNameEl) {
                productNameEl.textContent = 'CMP';
            }
            
            loadScenarios().then(() => {
                initializeScenarios();
                setupEventListeners();
                createParticles();
                loadRecordingSettings(); // 녹화 설정 로드
                setupModalRecordingToggle(); // 모달 녹화 토글 설정
                setupRecordingModalOptions(); // 녹화 설정 모달 옵션 초기화
                createSummaryCards(); // 요약 카드 생성
                initializeTheme(); // 테마 초기화
                setupTestOutputListeners(); // 테스트 출력 이벤트 리스너 설정
                setupConsoleLogCapture(); // 터미널 로그 캡처 설정
            });
        });

        // ============================================================================
        // 테스트 유형 선택 함수
        // ============================================================================
        function selectTestType(testType) {
            console.log('🟣 selectTestType 호출:', testType);
            
            if (testType === 'api') {
                // API 테스트는 아직 미구현
                showToast('🧪 API 테스트 기능은 준비 중입니다.', 'info');
                console.log('ℹ️ API 테스트는 Coming Soon');
                return;
            }
            
            if (testType === 'ui') {
                console.log('🖥️ UI 테스트 선택 - 메인 앱으로 전환');
                
                // 테스트 유형 화면 숨기기
                const testTypeScreen = document.getElementById('testTypeSelectionScreen');
                if (testTypeScreen) {
                    testTypeScreen.classList.add('hidden');
                    console.log('✅ 테스트 유형 화면 숨김');
                }
                
                // 메인 앱 컨텐츠 표시
                const mainAppContent = document.getElementById('mainAppContent');
                if (mainAppContent) {
                    mainAppContent.style.display = 'flex';
                    console.log('✅ 메인 앱 표시');
                }
                
                showToast('🖥️ UI 테스트 화면으로 전환되었습니다.', 'success');
            }
        }

        // 테마 초기화
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            setTheme(savedTheme);
        }

        // 테마 토글
        function toggleTheme() {
            const currentTheme = document.body.classList.contains('light-theme') ? 'light' : 'dark';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
        }

        // 테마 설정
        function setTheme(theme) {
            const themeIcon = document.getElementById('themeIcon');
            
            if (theme === 'light') {
                document.body.classList.add('light-theme');
                themeIcon.className = 'fas fa-sun';
                localStorage.setItem('theme', 'light');
            } else {
                document.body.classList.remove('light-theme');
                themeIcon.className = 'fas fa-moon';
                localStorage.setItem('theme', 'dark');
            }
        }

        // 파티클 생성
        function createParticles() {
            const particlesContainer = document.getElementById('particles');
            const particleCount = 20;

            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 6 + 's';
                particle.style.animationDuration = (Math.random() * 3 + 4) + 's';
                particlesContainer.appendChild(particle);
            }
        }

        // 원본 console 함수들을 전역에 저장 (addLog에서 사용하기 위해)
        window._originalConsoleLog = console.log;
        window._originalConsoleError = console.error;
        window._originalConsoleWarn = console.warn;
        window._originalConsoleInfo = console.info;

        // 시나리오별 로그 저장소
        const scenarioLogs = {};
        scenarioLogs['all'] = []; // 전체 로그 배열 초기화
        
        // 시나리오별 실시간 로그 저장소 (전역 유지)
        const scenarioRealTimeLogs = window.cmpRealTimeLogs || {};
        window.cmpRealTimeLogs = scenarioRealTimeLogs;
        
        // ==============================
        // 🔥 실시간 로그 IPC 리스너 즉시 등록
        // ==============================
        console.log('🎯 [CMP MAIN] IPC 리스너 등록 시작');
        
        ipcRenderer.on('test-output', (event, data) => {
            console.log('📥 [test-output] 이벤트 수신:', data);
            // alert 제거 (IPC 정상 작동 확인 완료)
            
            if (data && data.testType && data.data) {
                const scenarioId = data.testType.replace('scenario-', '');
                const numericScenarioId = parseInt(scenarioId);
                
                if (data.data.trim()) {
                    console.log(`🔵 [test-output] 시나리오 ${numericScenarioId}에 로그 추가 시도`);
                    
                    // 실시간 로그 저장
                    if (!scenarioRealTimeLogs[numericScenarioId]) {
                        scenarioRealTimeLogs[numericScenarioId] = [];
                        console.log(`📦 [test-output] 시나리오 ${numericScenarioId} 실시간 로그 배열 생성`);
                    }
                    
                    const logEntry = { timestamp: new Date(), message: data.data.trim() };
                    scenarioRealTimeLogs[numericScenarioId].push(logEntry);
                    console.log(`✅ [test-output] 로그 추가 완료 - 총 ${scenarioRealTimeLogs[numericScenarioId].length}개`);
                    
                    // UI 업데이트 (함수가 정의된 후에 호출)
                    setTimeout(() => {
                        if (typeof updateHistoryScenarioRealTimeLogView === 'function') {
                            updateHistoryScenarioRealTimeLogView(numericScenarioId);
                        } else {
                            console.log(`⚠️ updateHistoryScenarioRealTimeLogView 함수가 아직 정의되지 않음`);
                        }
                    }, 0);
                }
            }
        });
        
        console.log('✅ [CMP MAIN] IPC 리스너 등록 완료');
        // ==============================
        
        // 시나리오별 실행 기록 저장소
        const scenarioHistories = {};
        const scenarioReports = {};
        let selectedScenarios = [];
        let recordingSettings = {}; // 시나리오별 녹화 설정 저장

        // 선택된 시나리오 업데이트
        function updateSelectedScenarios() {
            console.log('체크박스 변경 이벤트 발생');
            
            selectedScenarios = [];
            document.querySelectorAll('.scenario-checkbox-input:checked').forEach(checkbox => {
                const scenarioId = parseInt(checkbox.id.replace('scenario-', ''));
                selectedScenarios.push(scenarioId);
            });
            
            console.log('선택된 시나리오:', selectedScenarios);
            
            // 선택된 시나리오 실행 버튼 상태 업데이트
            const runSelectedSequentialBtn = document.getElementById('runSelectedScenariosSequential');
            const runSelectedParallelBtn = document.getElementById('runSelectedScenariosParallel');
            const stopAllBtn = document.getElementById('stopAllTests');
            const selectedInfo = document.getElementById('selectedScenariosInfo');
            
            if (runSelectedSequentialBtn) {
                const isRunning = currentRunningScenarioIds.size > 0;
                const isDisabled = selectedScenarios.length === 0 || isRunning;
                runSelectedSequentialBtn.disabled = isDisabled;
                
                if (selectedScenarios.length > 0 && !isRunning) {
                    runSelectedSequentialBtn.innerHTML = `<i class="fas fa-list-ol" style="margin-right: 8px;"></i>직렬 수행 (${selectedScenarios.length}개)`;
                    runSelectedSequentialBtn.style.opacity = '1';
                    runSelectedSequentialBtn.style.pointerEvents = 'auto';
                    runSelectedSequentialBtn.style.transform = 'scale(1)';
                    runSelectedSequentialBtn.style.cursor = 'pointer';
                } else if (isRunning) {
                    runSelectedSequentialBtn.innerHTML = `<i class="fas fa-spinner fa-spin" style="margin-right: 8px;"></i>실행 중...`;
                    runSelectedSequentialBtn.style.opacity = '0.6';
                    runSelectedSequentialBtn.style.pointerEvents = 'none';
                    runSelectedSequentialBtn.style.transform = 'scale(0.95)';
                    runSelectedSequentialBtn.style.cursor = 'not-allowed';
                } else {
                    runSelectedSequentialBtn.innerHTML = `<i class="fas fa-list-ol" style="margin-right: 8px;"></i>직렬 수행`;
                    runSelectedSequentialBtn.style.opacity = '0.6';
                    runSelectedSequentialBtn.style.pointerEvents = 'none';
                    runSelectedSequentialBtn.style.transform = 'scale(0.95)';
                    runSelectedSequentialBtn.style.cursor = 'not-allowed';
                }
                console.log('직렬 수행 버튼 상태 업데이트:', runSelectedSequentialBtn.disabled, runSelectedSequentialBtn.innerHTML);
            }
            
            if (runSelectedParallelBtn) {
                const isRunning = currentRunningScenarioIds.size > 0;
                const isDisabled = selectedScenarios.length === 0 || isRunning;
                runSelectedParallelBtn.disabled = isDisabled;
                
                if (selectedScenarios.length > 0 && !isRunning) {
                    runSelectedParallelBtn.innerHTML = `<i class="fas fa-layer-group" style="margin-right: 8px;"></i>병렬 수행 (${selectedScenarios.length}개)`;
                    runSelectedParallelBtn.style.opacity = '1';
                    runSelectedParallelBtn.style.pointerEvents = 'auto';
                    runSelectedParallelBtn.style.transform = 'scale(1)';
                    runSelectedParallelBtn.style.cursor = 'pointer';
                } else if (isRunning) {
                    runSelectedParallelBtn.innerHTML = `<i class="fas fa-spinner fa-spin" style="margin-right: 8px;"></i>실행 중...`;
                    runSelectedParallelBtn.style.opacity = '0.6';
                    runSelectedParallelBtn.style.pointerEvents = 'none';
                    runSelectedParallelBtn.style.transform = 'scale(0.95)';
                    runSelectedParallelBtn.style.cursor = 'not-allowed';
                } else {
                    runSelectedParallelBtn.innerHTML = `<i class="fas fa-layer-group" style="margin-right: 8px;"></i>병렬 수행`;
                    runSelectedParallelBtn.style.opacity = '0.6';
                    runSelectedParallelBtn.style.pointerEvents = 'none';
                    runSelectedParallelBtn.style.transform = 'scale(0.95)';
                    runSelectedParallelBtn.style.cursor = 'not-allowed';
                }
                console.log('병렬 수행 버튼 상태 업데이트:', runSelectedParallelBtn.disabled, runSelectedParallelBtn.innerHTML);
            }
            
            // 전체 중단 버튼 상태 업데이트
            if (stopAllBtn) {
                const isRunning = currentRunningScenarioIds.size > 0;
                
                if (isRunning) {
                    stopAllBtn.style.opacity = '1';
                    stopAllBtn.style.pointerEvents = 'auto';
                    stopAllBtn.style.transform = 'scale(1)';
                    stopAllBtn.style.cursor = 'pointer';
                } else {
                    stopAllBtn.style.opacity = '0.6';
                    stopAllBtn.style.pointerEvents = 'none';
                    stopAllBtn.style.transform = 'scale(0.95)';
                    stopAllBtn.style.cursor = 'not-allowed';
                }
                console.log('전체 중단 버튼 상태 업데이트:', isRunning ? '활성화' : '비활성화');
            }
            
            // 선택 삭제 버튼 상태 업데이트
            const deleteSelectedBtn = document.getElementById('deleteSelectedScenarios');
            if (deleteSelectedBtn) {
                const isRunning = currentRunningScenarioIds.size > 0;
                const isDisabled = selectedScenarios.length === 0 || isRunning;
                
                if (selectedScenarios.length > 0 && !isRunning) {
                    deleteSelectedBtn.innerHTML = `<i class="fas fa-trash" style="margin-right: 6px;"></i>선택 삭제 (${selectedScenarios.length}개)`;
                    deleteSelectedBtn.style.opacity = '1';
                    deleteSelectedBtn.style.pointerEvents = 'auto';
                    deleteSelectedBtn.style.transform = 'scale(1)';
                    deleteSelectedBtn.style.cursor = 'pointer';
                } else {
                    deleteSelectedBtn.innerHTML = `<i class="fas fa-trash" style="margin-right: 6px;"></i>선택 삭제`;
                    deleteSelectedBtn.style.opacity = '0.6';
                    deleteSelectedBtn.style.pointerEvents = 'none';
                    deleteSelectedBtn.style.transform = 'scale(0.95)';
                    deleteSelectedBtn.style.cursor = 'not-allowed';
                }
                console.log('선택 삭제 버튼 상태 업데이트:', selectedScenarios.length > 0 && !isRunning ? '활성화' : '비활성화');
            }
            
            // 선택된 시나리오 정보 표시
            if (selectedInfo) {
                if (selectedScenarios.length > 0) {
                    const selectedTitles = selectedScenarios.map(id => {
                        const scenario = scenarios.find(s => s.id === id);
                        return `${id}번: ${scenario ? scenario.title : ''}`;
                    });
                    selectedInfo.innerHTML = `<strong>선택된 시나리오:</strong> ${selectedTitles.join(', ')}`;
                    selectedInfo.style.display = 'block';
                } else {
                    selectedInfo.style.display = 'none';
                }
            }
        }

        // 직렬 수행 함수 (전역 함수로도 등록)
        window.runSelectedScenariosSequential = async function() {
            console.log('=== runSelectedScenariosSequential 함수 호출됨 ===');
            console.log('선택된 시나리오:', selectedScenarios);
            
            if (selectedScenarios.length === 0) {
                showToast('실행할 시나리오를 선택해주세요.', 'warning');
                addLog('실행할 시나리오를 선택해주세요.', 'warning');
                return;
            }

            const scenarioNames = selectedScenarios.map(id => {
                const scenario = scenarios.find(s => s.id === id);
                return `${id}번: ${scenario ? scenario.title : ''}`;
            }).join(', ');
            
            showToast(`🚀 ${selectedScenarios.length}개의 시나리오를 직렬로 실행합니다.\n${scenarioNames}`, 'info');
            addLog(`${selectedScenarios.length}개의 시나리오를 직렬로 실행합니다.`, 'info');
            
            try {
                // 시나리오를 순차적으로 실행
                for (const scenarioId of selectedScenarios) {
                    await runScenario(scenarioId);
                }
                
                // 결과 분석
                const passScenarios = scenarios.filter(s => selectedScenarios.includes(s.id) && s.status === 'pass');
                const failedScenarios = scenarios.filter(s => selectedScenarios.includes(s.id) && s.status === 'failed');
                
                if (failedScenarios.length === 0) {
                    showToast(`🎉 모든 시나리오(${passScenarios.length}개)가 성공적으로 완료되었습니다!`, 'success');
                } else if (passScenarios.length === 0) {
                    showToast(`❌ 모든 시나리오(${failedScenarios.length}개) 실행이 실패했습니다.`, 'error');
                } else {
                    showToast(`⚠️ 시나리오 실행 완료: ${passScenarios.length}개 성공, ${failedScenarios.length}개 실패`, 'warning');
                }
                
                addLog('모든 선택된 시나리오 직렬 실행이 완료되었습니다.', 'success');
            } catch (error) {
                console.error('시나리오 직렬 실행 중 오류:', error);
                showToast('시나리오 직렬 실행 중 오류가 발생했습니다.', 'error');
                addLog(`시나리오 직렬 실행 중 오류가 발생했습니다: ${error.message}`, 'error');
            }
        };

        // 병렬 수행 함수 (전역 함수로도 등록)
        window.runSelectedScenariosParallel = async function() {
            console.log('=== runSelectedScenariosParallel 함수 호출됨 ===');
            console.log('선택된 시나리오:', selectedScenarios);
            
            if (selectedScenarios.length === 0) {
                showToast('실행할 시나리오를 선택해주세요.', 'warning');
                addLog('실행할 시나리오를 선택해주세요.', 'warning');
                return;
            }

            const scenarioNames = selectedScenarios.map(id => {
                const scenario = scenarios.find(s => s.id === id);
                return `${id}번: ${scenario ? scenario.title : ''}`;
            }).join(', ');
            
            showToast(`🚀 ${selectedScenarios.length}개의 시나리오를 병렬로 실행합니다.\n${scenarioNames}`, 'info');
            addLog(`${selectedScenarios.length}개의 시나리오를 병렬로 실행합니다.`, 'info');
            
            try {
                // 모든 시나리오를 병렬로 실행
                const promises = selectedScenarios.map(scenarioId => {
                    return runScenario(scenarioId);
                });
                
                // 모든 시나리오 완료 대기
                await Promise.all(promises);
                
                // 결과 분석
                const passScenarios = scenarios.filter(s => selectedScenarios.includes(s.id) && s.status === 'pass');
                const failedScenarios = scenarios.filter(s => selectedScenarios.includes(s.id) && s.status === 'failed');
                
                if (failedScenarios.length === 0) {
                    showToast(`🎉 모든 시나리오(${passScenarios.length}개)가 성공적으로 완료되었습니다!`, 'success');
                } else if (passScenarios.length === 0) {
                    showToast(`❌ 모든 시나리오(${failedScenarios.length}개) 실행이 실패했습니다.`, 'error');
                } else {
                    showToast(`⚠️ 시나리오 실행 완료: ${passScenarios.length}개 성공, ${failedScenarios.length}개 실패`, 'warning');
                }
                
                addLog('모든 선택된 시나리오 병렬 실행이 완료되었습니다.', 'success');
            } catch (error) {
                console.error('시나리오 병렬 실행 중 오류:', error);
                showToast('시나리오 병렬 실행 중 오류가 발생했습니다.', 'error');
                addLog(`시나리오 병렬 실행 중 오류가 발생했습니다: ${error.message}`, 'error');
            }
        };

        // 요약 카드 생성 (시나리오 목록 탭용)
        function createSummaryCards() {
            const summaryContainer = document.getElementById('summaryCards');
            if (!summaryContainer) {
                console.log('summaryCards 요소를 찾을 수 없습니다.');
                return;
            }
            
            console.log('createSummaryCards 함수 호출됨');
            console.log('scenarios 배열:', scenarios);
            
            // 통계 계산
            const totalScenarios = scenarios.length;
            const passScenarios = scenarios.filter(s => s.status === 'pass' || s.status === 'pass').length;
            const failedScenarios = scenarios.filter(s => s.status === 'failed' || s.status === 'fail').length;
            const interruptedScenarios = scenarios.filter(s => s.status === 'stopped').length;
            const notRunScenarios = scenarios.filter(s => s.status === 'ready').length;
            
            console.log('통계 계산 결과:', {
                total: totalScenarios,
                pass: passScenarios,
                failed: failedScenarios,
                interrupted: interruptedScenarios,
                notRun: notRunScenarios
            });
            
            // 수행률 계산: (성공+실패)/총 시나리오
            const executionRate = totalScenarios > 0 ? ((passScenarios + failedScenarios) / totalScenarios * 100).toFixed(1) : '0.0';
            
            // 성공률 계산: 중단된 시나리오는 제외하고 계산
            const executedScenarios = passScenarios + failedScenarios + interruptedScenarios;
            const successRate = executedScenarios > 0 ? (passScenarios / executedScenarios * 100).toFixed(1) : '0.0';
            
            summaryContainer.innerHTML = `
                <div class="summary-card total">
                    <div class="number total">${totalScenarios}</div>
                    <div class="label">총 시나리오</div>
                </div>
                <div class="summary-card success">
                    <div class="number success">${passScenarios}</div>
                    <div class="label">성공</div>
                </div>
                <div class="summary-card failure">
                    <div class="number failure">${failedScenarios}</div>
                    <div class="label">실패</div>
                </div>
                <div class="summary-card not-run">
                    <div class="number not-run">${notRunScenarios}</div>
                    <div class="label">미실행</div>
                </div>
                <div class="summary-card execution">
                    <div class="number execution">${executionRate}%</div>
                    <div class="label">수행률</div>
                </div>
                <div class="summary-card rate">
                    <div class="number rate">${successRate}%</div>
                    <div class="label">성공률</div>
                </div>
            `;
            
            console.log('요약 카드 생성 완료');
        }

        // 시나리오 초기화
        function initializeScenarios() {
            console.log('initializeScenarios 함수 호출됨');
            
            // 시나리오 목록 탭 초기화
            initializeScenarioTab();
            
            // 이력 관리 탭 초기화
            initializeHistoryTab();
        }

        // 시나리오 목록 탭 초기화
        function initializeScenarioTab() {
            const grid = document.getElementById('scenarioGrid');
            grid.innerHTML = '';

            // 선택된 시나리오 정보 표시 영역 추가
            const selectedInfo = document.createElement('div');
            selectedInfo.id = 'selectedScenariosInfo';
            selectedInfo.className = 'selected-scenarios-info';
            selectedInfo.style.display = 'none';
            selectedInfo.style.marginBottom = '15px';
            selectedInfo.style.padding = '10px 15px';
            selectedInfo.style.backgroundColor = 'rgba(102, 126, 234, 0.1)';
            selectedInfo.style.border = '1px solid rgba(102, 126, 234, 0.3)';
            selectedInfo.style.borderRadius = '8px';
            selectedInfo.style.color = '#1d80f8';
            selectedInfo.style.fontSize = '0.9em';
            
            grid.appendChild(selectedInfo);

            // 선택된 시나리오 실행 및 전체 중단 버튼 컨테이너 추가
            const buttonContainerHtml = `
                <div class="button-container" style="display: flex; gap: 12px; margin-bottom: 20px; align-items: center;">
                    <button id="runSelectedScenariosSequential" class="btn btn-success run-selected-btn" 
                            disabled 
                            style="flex: 1; padding: 12px 20px; font-size: 0.9em; font-weight: 500; border-radius: 8px; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1); min-height: 48px; opacity: 0.6; pointer-events: none;">
                        <i class="fas fa-list-ol" style="margin-right: 8px;"></i>
                        직렬 수행
                    </button>
                    <button id="runSelectedScenariosParallel" class="btn btn-info run-selected-btn" 
                            disabled 
                            style="flex: 1; padding: 12px 20px; font-size: 0.9em; font-weight: 500; border-radius: 8px; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1); min-height: 48px; opacity: 0.6; pointer-events: none;">
                        <i class="fas fa-layer-group" style="margin-right: 8px;"></i>
                        병렬 수행
                    </button>
                    <button id="stopAllTests" class="btn btn-danger stop-all-btn" 
                            style="flex: 1; padding: 12px 20px; font-size: 0.9em; font-weight: 500; border-radius: 8px; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1); min-height: 48px; opacity: 0.6; pointer-events: none;">
                        <i class="fas fa-stop" style="margin-right: 6px;"></i>
                        전체 중단
                    </button>
                    <button id="resetAllScenarios" class="btn btn-warning reset-all-btn" 
                            style="flex: 1; padding: 12px 20px; font-size: 0.9em; font-weight: 500; border-radius: 8px; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1); min-height: 48px;">
                        <i class="fas fa-undo" style="margin-right: 6px;"></i>
                        전체 초기화
                    </button>
                    <button id="deleteSelectedScenarios" class="btn btn-danger delete-selected-btn" 
                            style="flex: 1; padding: 12px 20px; font-size: 0.9em; font-weight: 500; border-radius: 8px; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1); min-height: 48px; opacity: 0.6; pointer-events: none;">
                        <i class="fas fa-trash" style="margin-right: 6px;"></i>
                        선택 삭제
                    </button>
                </div>
            `;
            grid.insertAdjacentHTML('beforeend', buttonContainerHtml);
            console.log('버튼 생성 완료 (HTML 방식)');
            
            // 버튼들이 실제로 생성되었는지 확인
            const createdSequentialBtn = document.getElementById('runSelectedScenariosSequential');
            const createdParallelBtn = document.getElementById('runSelectedScenariosParallel');
            const createdStopBtn = document.getElementById('stopAllTests');
            
            if (createdSequentialBtn) {
                console.log('직렬 수행 버튼이 DOM에 생성됨:', createdSequentialBtn);
                console.log('버튼의 disabled 상태:', createdSequentialBtn.disabled);
                
                // 직렬 수행 버튼 이벤트 리스너 등록
                createdSequentialBtn.addEventListener('click', function(e) {
                    console.log('직렬 수행 버튼 클릭 이벤트 발생 (addEventListener)');
                    e.preventDefault();
                    runSelectedScenariosSequential();
                });
            } else {
                console.error('직렬 수행 버튼이 DOM에 생성되지 않음!');
            }
            
            if (createdParallelBtn) {
                console.log('병렬 수행 버튼이 DOM에 생성됨:', createdParallelBtn);
                console.log('버튼의 disabled 상태:', createdParallelBtn.disabled);
                
                // 병렬 수행 버튼 이벤트 리스너 등록
                createdParallelBtn.addEventListener('click', function(e) {
                    console.log('병렬 수행 버튼 클릭 이벤트 발생 (addEventListener)');
                    e.preventDefault();
                    runSelectedScenariosParallel();
                });
            } else {
                console.error('병렬 수행 버튼이 DOM에 생성되지 않음!');
            }
            
            if (createdStopBtn) {
                console.log('전체 중단 버튼이 DOM에 생성됨:', createdStopBtn);
                
                // 전체 중단 버튼 이벤트 리스너 등록
                createdStopBtn.addEventListener('click', function(e) {
                    console.log('전체 중단 버튼 클릭 이벤트 발생');
                    e.preventDefault();
                    stopAllTests();
                });
            } else {
                console.error('전체 중단 버튼이 DOM에 생성되지 않음!');
            }

            // 전체 초기화 버튼 이벤트 리스너 등록
            const createdResetBtn = document.getElementById('resetAllScenarios');
            if (createdResetBtn) {
                console.log('전체 초기화 버튼이 DOM에 생성됨:', createdResetBtn);
                
                createdResetBtn.addEventListener('click', function(e) {
                    console.log('전체 초기화 버튼 클릭 이벤트 발생');
                    e.preventDefault();
                    resetAllScenarios();
                });
            } else {
                console.error('전체 초기화 버튼이 DOM에 생성되지 않음!');
            }

            // 선택 삭제 버튼 이벤트 리스너 등록
            const createdDeleteBtn = document.getElementById('deleteSelectedScenarios');
            if (createdDeleteBtn) {
                console.log('선택 삭제 버튼이 DOM에 생성됨:', createdDeleteBtn);
                
                createdDeleteBtn.addEventListener('click', function(e) {
                    console.log('선택 삭제 버튼 클릭 이벤트 발생');
                    e.preventDefault();
                    deleteSelectedScenarios();
                });
            } else {
                console.error('선택 삭제 버튼이 DOM에 생성되지 않음!');
            }

            // 저장된 시나리오 상태 로드
            loadScenarioStatus();

            scenarios.forEach(scenario => {
                const card = createScenarioCard(scenario);
                grid.appendChild(card);
                
                // 시나리오별 로그 및 기록 초기화
                scenarioLogs[scenario.id] = [];
                scenarioReports[scenario.id] = {
                    status: 'not_run',
                    lastRun: null,
                    reportUrl: null
                };
                
                // 저장된 기록 로드
                try {
                    const savedHistory = localStorage.getItem(`cmp-scenario-history-${scenario.id}`);
                    if (savedHistory) {
                        scenarioHistories[scenario.id] = JSON.parse(savedHistory);
                    } else {
                        scenarioHistories[scenario.id] = [];
                    }
                } catch (error) {
                    console.error(`시나리오 ${scenario.id} 기록 로드 중 오류:`, error);
                    scenarioHistories[scenario.id] = [];
                }
                
                // 테스트용 샘플 로그 추가 (실제 환경에서는 제거)
                addLog(`시나리오 ${scenario.id} 초기화 완료`, 'info', scenario.id);
                addLog(`시나리오 ${scenario.id}: ${scenario.title} 준비됨`, 'success', scenario.id);
            });

            // 요약 카드 생성
            createSummaryCards();

            // Expandable section 초기화
            initializeExpandableSections();
        }

        // 시나리오 카드 생성 (시나리오 목록용)
        function createScenarioCard(scenario) {
            const card = document.createElement('div');
            card.className = `scenario-card ${scenario.status}`;
            card.dataset.scenarioId = scenario.id;

            card.innerHTML = `
                <div class="scenario-header">
                    <div class="scenario-icon">${scenario.id}</div>
                    <div class="scenario-title">${scenario.title}</div>
                    <div class="scenario-checkbox">
                        <input type="checkbox" id="scenario-${scenario.id}" class="scenario-checkbox-input" onchange="updateSelectedScenarios()">
                        <label for="scenario-${scenario.id}" class="scenario-checkbox-label"></label>
                    </div>
                </div>
                <div class="scenario-description">${scenario.description}</div>
                <div class="scenario-status">
                    <span class="status-badge ${scenario.status}">${getStatusText(scenario.status)}</span>
                    <div class="scenario-actions">
                        <div class="scenario-actions-row">
                            <button class="action-btn run-btn" onclick="runScenario(${scenario.id}); event.stopPropagation();" title="실행">
                                <i class="fas fa-play"></i>
                                <span class="btn-text">실행</span>
                            </button>
                            <button class="action-btn stop-btn" onclick="stopScenario(${scenario.id}); event.stopPropagation();" id="stop-btn-${scenario.id}" style="display: none;" title="중단">
                                <i class="fas fa-stop"></i>
                                <span class="btn-text">중단</span>
                            </button>
                            <!-- 설정 버튼 주석처리: test-settings.json 파일로 직접 관리 -->
                            <!--
                            <button class="action-btn settings-btn" onclick="openScenarioModal(${scenario.id}); event.stopPropagation();" title="설정">
                                <i class="fas fa-cog"></i>
                                <span class="btn-text">설정</span>
                            </button>
                            -->
                            <button class="action-btn record-btn" onclick="toggleRecording(${scenario.id}); event.stopPropagation();" id="recording-btn-${scenario.id}" title="녹화">
                                <i class="fas fa-video" id="recording-icon-${scenario.id}"></i>
                                <span class="btn-text" id="record-text-${scenario.id}">녹화 OFF</span>
                            </button>
                            <button class="action-btn reset-btn" onclick="resetScenarioStatus(${scenario.id}); event.stopPropagation();" title="상태 초기화">
                                <i class="fas fa-undo"></i>
                                <span class="btn-text">상태 초기화</span>
                            </button>
                        </div>
                    </div>
                </div>
                

            `;

            // 카드 클릭 시 체크박스 토글 (버튼 영역 제외)
            card.addEventListener('click', (e) => {
                // 체크박스 영역 클릭 시: 체크박스 자체의 동작만 허용하고 카드 선택 로직은 실행하지 않음
                if (e.target.closest('.scenario-checkbox')) {
                    // 체크박스의 기본 동작을 허용하고, 카드 본체 클릭 로직만 건너뜀
                    return;
                }
                
                // 액션 버튼 클릭 시 카드 선택 방지
                if (e.target.closest('.scenario-actions') || e.target.closest('.action-btn')) {
                    return;
                }
                
                // 다른 버튼 클릭 시에도 카드 선택 방지
                if (e.target.closest('.btn') || e.target.closest('.donut-chart-container')) {
                    return;
                }
                
                // 카드 본체 클릭 시에만 체크박스 토글
                const checkbox = card.querySelector('.scenario-checkbox-input');
                checkbox.checked = !checkbox.checked;
                updateSelectedScenarios();
            });

        // 초기 실행/중단 버튼 상태 설정
        const runBtn = card.querySelector('.run-btn');
        const stopBtn = card.querySelector('.stop-btn');
        if (runBtn && stopBtn) {
            if (scenario.status === 'running') {
                runBtn.style.display = 'none';
                stopBtn.style.display = 'flex';
            } else {
                runBtn.style.display = 'flex';
                stopBtn.style.display = 'none';
            }
        }

        // 초기 녹화 버튼 상태 설정
        const recordingBtn = card.querySelector('.record-btn');
        const recordingIcon = card.querySelector('#recording-icon-' + scenario.id);
        const recordText = card.querySelector('#record-text-' + scenario.id);
        
        if (recordingBtn && recordingIcon && recordText) {
            const isRecordingEnabled = recordingSettings[scenario.id] || false;
            const isScenarioRunning = scenario.status === 'running';
            
            if (isRecordingEnabled && isScenarioRunning) {
                recordingBtn.classList.add('recording-active');
                recordingIcon.className = 'fas fa-stop';
                recordText.textContent = '녹화중';
            } else if (isRecordingEnabled) {
                recordingBtn.classList.add('recording-on');
                recordingIcon.className = 'fas fa-video';
                recordText.textContent = '녹화 ON';
            } else {
                recordingIcon.className = 'fas fa-video';
                recordText.textContent = '녹화 OFF';
            }
        }

            return card;
        }

        // 이력 관리용 시나리오 카드 생성 (시나리오 목록과 완전히 동일한 구조, 버튼만 다름)
        function createHistoryScenarioCard(scenario) {
            const card = document.createElement('div');
            card.className = `scenario-card ${scenario.status}`;
            card.dataset.scenarioId = scenario.id;

            card.innerHTML = `
                <div class="scenario-header">
                    <div class="scenario-icon">${scenario.id}</div>
                    <div class="scenario-title">${scenario.title}</div>
                </div>
                <div class="scenario-description">${scenario.description}</div>
                <div class="scenario-status">
                    <span class="status-badge ${scenario.status}">${getStatusText(scenario.status)}</span>
                    <div class="scenario-actions">
                        <div class="scenario-actions-row">
                                                   <button class="action-btn history-btn" onclick="toggleHistoryScenarioHistory(${scenario.id}); event.stopPropagation();" title="실행 기록">
                           <i class="fas fa-history"></i>
                           <span class="btn-text">실행 기록</span>
                       </button>
                       <button class="action-btn log-btn" onclick="toggleHistoryScenarioLog(${scenario.id}); event.stopPropagation();" title="실행 로그">
                           <i class="fas fa-terminal"></i>
                           <span class="btn-text">실행 로그</span>
                       </button>
                       <button class="action-btn realtime-log-btn" onclick="toggleHistoryScenarioRealTimeLog(${scenario.id}); event.stopPropagation();" title="실시간 로그" style="
                           background: linear-gradient(135deg, #8d6e63 0%, #5d4037 100%);
                       ">
                           <i class="fas fa-stream"></i>
                           <span class="btn-text">실시간 로그</span>
                       </button>
                        </div>
                    </div>
                </div>
            `;

            // 카드 클릭 시 아무 동작 안함 (이력 관리에서는 선택 불필요)
            card.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
            });

            return card;
        }

        // 이력 관리 탭 초기화
        function initializeHistoryTab() {
            console.log('initializeHistoryTab 함수 호출됨');
            
            // 요약 카드 렌더링 (시나리오 목록과 동일한 구조)
            createSummaryCardsForHistory();
            
            const grid = document.getElementById('historyScenarioGrid');
            grid.innerHTML = '';

            // 각 시나리오에 대해 시나리오 목록과 동일한 카드 생성 (버튼만 다름)
            scenarios.forEach(scenario => {
                const card = createHistoryScenarioCard(scenario);
                grid.appendChild(card);
            });

            console.log(`이력 관리 탭에 ${scenarios.length}개의 시나리오 카드 생성 완료`);
        }





        // addLog 없이 직접 로그를 표시하는 함수
        function addDirectLog(message, level = 'info', scenarioId = null) {
            const timestamp = new Date();
            
            // 시나리오별 로그에 직접 추가
            if (scenarioId) {
                if (!scenarioLogs[scenarioId]) {
                    scenarioLogs[scenarioId] = [];
                }
                scenarioLogs[scenarioId].push({
                    timestamp,
                    message,
                    level,
                    scenarioId
                });
                
                // 해당 시나리오의 로그 창이 없으면 자동으로 생성 (하지만 자동으로 열지 않음)
                let logContainer = document.getElementById(`history-scenario-log-${scenarioId}`);
                if (!logContainer) {
                    // 이력 관리 탭에서 시나리오 카드 찾기
                    const scenarioCard = document.querySelector(`#history .scenario-card[data-scenario-id="${scenarioId}"]`);
                    if (scenarioCard) {
                        logContainer = createHistoryLogContainer(scenarioId);
                        scenarioCard.parentNode.insertBefore(logContainer, scenarioCard.nextSibling);
                        // ⚠️ 자동 포커싱 제거 - 사용자가 '실행 로그' 버튼을 클릭해야만 열림
                        // logContainer.style.display = 'block';
                    }
                }
                
                // 로그 창이 있으면 즉시 업데이트
                if (logContainer) {
                    updateHistoryScenarioLogView(scenarioId);
                }
            }
            
            // 전체 로그에도 추가 (시스템 로그용)
            if (!scenarioLogs['all']) {
                scenarioLogs['all'] = [];
            }
            scenarioLogs['all'].push({
                timestamp,
                message,
                level,
                scenarioId
            });
            
            // 콘솔에도 출력 (디버깅용, 원본 console.log 사용하여 무한 재귀 방지)
            if (window._originalConsoleLog) {
                window._originalConsoleLog(`[${timestamp.toLocaleString('ko-KR')}] [${level.toUpperCase()}] ${message}${scenarioId ? ` (시나리오 ${scenarioId})` : ''}`);
            }
        }

        // 이력 관리 전체 로그 지우기
        function clearHistoryOverallLogs() {
            if (confirm('전체 실행 로그를 지우시겠습니까?')) {
                scenarioLogs['all'] = [];
                addLog('이력 관리 전체 로그가 초기화되었습니다.', 'info');
            }
        }



        // 이력 관리 전체 로그 내보내기
        function exportHistoryOverallLogs() {
            const logs = scenarioLogs['all'] || [];
            if (logs.length === 0) {
                showToast('내보낼 로그가 없습니다.', 'warning');
                return;
            }
            
            const logText = logs.map(log => `[${log.timestamp}] ${log.message}`).join('\n');
            const blob = new Blob([logText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `trombone-logs-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            showToast('로그가 성공적으로 내보내졌습니다.', 'success');
        }

        // 이력 관리 탭용 요약 카드 생성 (시나리오 목록과 완전히 동일)
        function createSummaryCardsForHistory() {
            const summaryContainer = document.getElementById('historySummaryCards');
            if (!summaryContainer) {
                console.log('historySummaryCards 요소를 찾을 수 없습니다.');
                return;
            }
            
            console.log('createSummaryCardsForHistory 함수 호출됨');
            console.log('scenarios 배열:', scenarios);
            
            // 통계 계산
            const totalScenarios = scenarios.length;
            const passScenarios = scenarios.filter(s => s.status === 'pass' || s.status === 'pass').length;
            const failedScenarios = scenarios.filter(s => s.status === 'failed' || s.status === 'fail').length;
            const interruptedScenarios = scenarios.filter(s => s.status === 'stopped').length;
            const notRunScenarios = scenarios.filter(s => s.status === 'ready').length;
            
            console.log('통계 계산 결과:', {
                total: totalScenarios,
                pass: passScenarios,
                failed: failedScenarios,
                interrupted: interruptedScenarios,
                notRun: notRunScenarios
            });
            
            // 수행률 계산: (성공+실패)/총 시나리오
            const executionRate = totalScenarios > 0 ? ((passScenarios + failedScenarios) / totalScenarios * 100).toFixed(1) : '0.0';
            
            // 성공률 계산: 중단된 시나리오는 제외하고 계산
            const executedScenarios = passScenarios + failedScenarios + interruptedScenarios;
            const successRate = executedScenarios > 0 ? (passScenarios / executedScenarios * 100).toFixed(1) : '0.0';
            
            summaryContainer.innerHTML = `
                <div class="summary-card total">
                    <div class="number total">${totalScenarios}</div>
                    <div class="label">총 시나리오</div>
                </div>
                <div class="summary-card success">
                    <div class="number success">${passScenarios}</div>
                    <div class="label">성공</div>
                </div>
                <div class="summary-card failure">
                    <div class="number failure">${failedScenarios}</div>
                    <div class="label">실패</div>
                </div>
                <div class="summary-card not-run">
                    <div class="number not-run">${notRunScenarios}</div>
                    <div class="label">미실행</div>
                </div>
                <div class="summary-card execution">
                    <div class="number execution">${executionRate}%</div>
                    <div class="label">수행률</div>
                </div>
                <div class="summary-card rate">
                    <div class="number rate">${successRate}%</div>
                    <div class="label">성공률</div>
                </div>
            `;
            
            console.log('이력 관리 요약 카드 생성 완료');
        }





        // 상태 텍스트 반환
        function getStatusText(status) {
            const statusMap = {
                'ready': '미실행',
                'running': '실행중',
                'pass': '성공',
                'completed': '성공',  // 하위 호환성
                'fail': '실패',
                'failed': '실패',  // 하위 호환성
                'stopped': '중단됨'
            };
            return statusMap[status] || '미실행';
        }
        





        // 시나리오 기록 토글 (카드 밖에 표시)
        function toggleScenarioHistory(scenarioId) {
            const scenarioCard = document.querySelector(`[data-scenario-id="${scenarioId}"]`);
            if (!scenarioCard) return;
            
            // 기존 기록창이 있는지 확인
            let historyContainer = document.getElementById(`scenario-history-${scenarioId}`);
            const isVisible = historyContainer && historyContainer.style.display !== 'none';
            
            if (isVisible) {
                // 기록창 숨기기
                historyContainer.style.display = 'none';
                } else {
                // 기록창이 없으면 생성
                if (!historyContainer) {
                    historyContainer = createHistoryContainer(scenarioId);
                    // 시나리오 카드 다음에 삽입
                    scenarioCard.parentNode.insertBefore(historyContainer, scenarioCard.nextSibling);
                }
                
                historyContainer.style.display = 'block';
                
                // 기록 내용 로드
                loadScenarioHistory(scenarioId);
            }
        }
        
        // 기록창 컨테이너 생성
        function createHistoryContainer(scenarioId) {
            const container = document.createElement('div');
            container.id = `scenario-history-${scenarioId}`;
            container.className = 'scenario-history-container';
            container.style.display = 'none';
            
            container.innerHTML = `
                <div class="history-header">
                    <div class="history-title">
                        <i class="fas fa-history"></i>
                        <span>시나리오 ${scenarioId} 실행 기록</span>
                    </div>
                    <button class="history-close-btn" onclick="toggleScenarioHistory(${scenarioId})">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="history-content" id="history-content-${scenarioId}">
                    <div class="history-loading">
                        <i class="fas fa-spinner fa-spin"></i> 기록을 불러오는 중...
                    </div>
                </div>
            `;
            
            return container;
        }
        
        // 시나리오 실행 기록 저장
        function saveScenarioHistory(scenarioId, historyData) {
            // 시나리오별 기록 배열 초기화
            if (!scenarioHistories[scenarioId]) {
                scenarioHistories[scenarioId] = [];
            }
            
            // 새로운 기록 추가 (최신 순으로 정렬)
            const newHistoryEntry = {
                ...historyData,
                id: Date.now() // 고유 ID
            };
            
            scenarioHistories[scenarioId].unshift(newHistoryEntry);
            
            console.log(`📊 시나리오 ${scenarioId} 실행 기록 저장:`, {
                totalRecords: scenarioHistories[scenarioId].length,
                newRecord: newHistoryEntry
            });
            
            // 최대 50개까지만 유지
            if (scenarioHistories[scenarioId].length > 50) {
                scenarioHistories[scenarioId] = scenarioHistories[scenarioId].slice(0, 50);
            }
            
            // localStorage에 저장
            try {
                localStorage.setItem(`cmp-scenario-history-${scenarioId}`, JSON.stringify(scenarioHistories[scenarioId]));
                console.log(`✅ 시나리오 ${scenarioId} 실행 기록 localStorage 저장 완료`);
            } catch (error) {
                console.error('시나리오 기록 저장 중 오류:', error);
            }
        }
        
        // 시나리오 기록의 리포트 경로 업데이트
        function updateScenarioHistoryReportPath(scenarioId, timestamp, reportPath) {
            if (!scenarioHistories[scenarioId]) return;
            
            // 해당 타임스탬프의 기록 찾기
            const historyIndex = scenarioHistories[scenarioId].findIndex(history => history.timestamp === timestamp);
            if (historyIndex !== -1) {
                // 리포트 경로 업데이트
                scenarioHistories[scenarioId][historyIndex].reportPath = reportPath;
                
                // localStorage에 저장
                try {
                    localStorage.setItem(`cmp-scenario-history-${scenarioId}`, JSON.stringify(scenarioHistories[scenarioId]));
                    console.log(`시나리오 ${scenarioId} 기록의 리포트 경로가 업데이트되었습니다: ${reportPath}`);
                } catch (error) {
                    console.error('시나리오 기록 업데이트 중 오류:', error);
                }
            }
        }
        
        // 시나리오 실행 기록 초기화 (테스트용)
        function clearScenarioHistory(scenarioId) {
            try {
                localStorage.removeItem(`cmp-scenario-history-${scenarioId}`);
                scenarioHistories[scenarioId] = [];
                console.log(`시나리오 ${scenarioId} 실행 기록이 초기화되었습니다.`);
            } catch (error) {
                console.error('시나리오 기록 초기화 중 오류:', error);
            }
        }
        
        // 전역 함수로 노출 (브라우저 콘솔에서 사용)
        window.clearScenarioHistory = clearScenarioHistory;
        
        // 모든 시나리오 실행 기록 삭제 (브라우저 콘솔에서 사용)
        function clearAllScenarioHistory() {
            try {
                for (let i = 1; i <= 21; i++) {
                    localStorage.removeItem(`cmp-scenario-history-${i}`);
                    if (scenarioHistories[i]) {
                        scenarioHistories[i] = [];
                    }
                }
                console.log('✅ 모든 시나리오 실행 기록이 삭제되었습니다.');
            } catch (error) {
                console.error('모든 시나리오 기록 삭제 중 오류:', error);
            }
        }
        
        // 전역 함수로 노출
        window.clearAllScenarioHistory = clearAllScenarioHistory;
        

        
        // 파일 시스템에서 시나리오 히스토리 가져오기 (VIOLA 방식)
        async function getScenarioHistoryFromFiles(scenarioId) {
            try {
                // 시나리오 디렉토리의 index.json 파일에서 파일 목록 로드
                const indexResponse = await fetch(`./custom-reports/scenario-${scenarioId}/index.json`);
                
                if (!indexResponse.ok) {
                    console.warn(`시나리오 ${scenarioId}의 인덱스 파일을 찾을 수 없습니다.`);
                    return [];
                }
                
                const indexData = await indexResponse.json();
                const reportFiles = indexData.files || [];
                
                console.log(`📊 시나리오 ${scenarioId} 인덱스에서 로드된 파일 수:`, reportFiles.length);
                
                const history = [];
                
                for (const file of reportFiles) {
                    const timestampMatch = file.match(/custom-report-(.+)\.html/);
                    if (timestampMatch) {
                        const timestamp = timestampMatch[1];
                        
                        try {
                            // 개선된 타임스탬프 파싱
                            let date = null;
                            
                            // 여러 형식의 타임스탬프 파싱 시도
                            const formats = [
                                // ISO 형식: 2025-10-01T01-14-15
                                () => {
                                    const dateParts = timestamp.split('T');
                                    if (dateParts.length === 2) {
                                        const dateStr = dateParts[0];
                                        let timeStr = dateParts[1];
                                        
                                        // 시간 부분에서 하이픈을 콜론으로 변경
                                        if (timeStr.includes('-')) {
                                            const timeParts = timeStr.split('-');
                                            if (timeParts.length >= 3) {
                                                timeStr = timeParts.slice(0, 3).join(':');
                                            }
                                        }
                                        
                                        const isoTimestamp = `${dateStr}T${timeStr}.000Z`;
                                        return new Date(isoTimestamp);
                                    }
                                    return null;
                                },
                                // 직접 파싱: 2025-10-01T01-14-15
                                () => {
                                    const cleanTimestamp = timestamp.replace(/-/g, ':').replace('T', 'T');
                                    return new Date(cleanTimestamp);
                                },
                                // 파일 수정 시간 사용 (fallback)
                                () => {
                                    console.log(`📊 타임스탬프 파싱 실패, 파일 수정 시간 사용: ${file}`);
                                    return new Date(); // 현재 시간 사용
                                }
                            ];
                            
                            for (const format of formats) {
                                try {
                                    date = format();
                                    if (date && !isNaN(date.getTime())) {
                                        break;
                                    }
                                } catch (e) {
                                    continue;
                                }
                            }
                            
                            if (date && !isNaN(date.getTime())) {
                                // duration 정보 추가
                                let duration = null;
                                let durationText = 'N/A';
                                
                                // 기본값 설정
                                let status = 'pass';
                                
                                try {
                                    // 실제 리포트 파일에서 duration과 status 정보 추출
                                    const reportFilePath = `./custom-reports/scenario-${scenarioId}/${file}`;
                                    const reportInfo = await extractDurationFromReport(reportFilePath);
                                    duration = reportInfo.duration;
                                    durationText = reportInfo.durationText;
                                    status = reportInfo.status || 'pass';
                                    
                                    console.log(`📊 Duration 및 Status 정보 추출 완료: ${durationText}, ${status}`);
                                } catch (extractError) {
                                    console.warn(`⚠️ Duration/Status 정보 추출 실패:`, extractError);
                                    duration = 0;
                                    durationText = '알 수 없음';
                                    status = 'pass';
                                }
                                
                                history.push({
                                    filename: file,
                                    timestamp: timestamp,
                                    date: date,
                                    displayDate: date.toLocaleString('ko-KR'),
                                    reportPath: `./custom-reports/scenario-${scenarioId}/${file}`,
                                    status: status,
                                    formattedTimestamp: date.toLocaleString('ko-KR'),
                                    timestampMs: date.getTime(),
                                    duration: duration,
                                    durationText: durationText,
                                    startTime: date.toISOString(),
                                    endTime: date.toISOString()
                                });
                                console.log(`✅ 타임스탬프 파싱 성공: ${timestamp} -> ${date.toLocaleString('ko-KR')}`);
                            } else {
                                console.warn(`⚠️ 모든 타임스탬프 파싱 방법 실패: ${timestamp}`);
                            }
                        } catch (parseError) {
                            console.warn(`⚠️ 타임스탬프 파싱 오류: ${timestamp}`, parseError.message);
                        }
                    }
                }
                
                // 최신 순으로 정렬
                history.sort((a, b) => b.date - a.date);
                
                console.log(`📊 시나리오 ${scenarioId} 히스토리 로드 완료:`, history.length, '개');
                return history;
                
            } catch (error) {
                console.error(`시나리오 ${scenarioId} 히스토리 로드 중 오류:`, error);
                return [];
            }
        }
        
        // 리포트 HTML에서 duration과 status 추출 (VIOLA 방식)
        async function extractDurationFromReport(reportPath) {
            try {
                console.log(`📊 리포트에서 duration과 status 추출 시도: ${reportPath}`);
                const response = await fetch(reportPath);
                if (!response.ok) {
                    console.warn(`⚠️ 리포트 파일을 읽을 수 없음: ${reportPath}`);
                    return { duration: 0, durationText: '알 수 없음', status: 'completed' };
                }

                const htmlContent = await response.text();

                // Status 추출 (우선순위: 메타 정보 > 개별 status-badge)
                let status = 'pass';
                
                // 1순위: 메타 정보의 "결과: 성공/실패" 패턴 (최종 결과)
                const resultSuccessMatch = htmlContent.match(/결과[:\s]*성공/i);
                const resultFailMatch = htmlContent.match(/결과[:\s]*실패/i);
                
                if (resultFailMatch) {
                    status = 'failed';
                    console.log(`✅ Status 감지: failed (메타 정보 - 결과: 실패)`);
                } else if (resultSuccessMatch) {
                    status = 'pass';
                    console.log(`✅ Status 감지: pass (메타 정보 - 결과: 성공)`);
                } else {
                    // 2순위: status-badge 패턴
                    const hasFailStatus = htmlContent.includes('status-badge fail') || htmlContent.includes('class="status-fail"');
                    const hasStoppedStatus = htmlContent.includes('stopped') || htmlContent.includes('중단');
                    const hasNotTestStatus = htmlContent.includes('status-not-test');
                    const hasPassStatus = htmlContent.includes('status-badge pass') || htmlContent.includes('status-pass');
                    
                    if (hasFailStatus || hasStoppedStatus) {
                        status = 'failed';
                        console.log(`✅ Status 감지: failed (status-badge)`);
                    } else if (hasNotTestStatus && !hasPassStatus) {
                        status = 'not-run';
                        console.log(`✅ Status 감지: not-run`);
                    } else if (hasPassStatus) {
                        status = 'pass';
                        console.log(`✅ Status 감지: pass (status-badge)`);
                    }
                }

                // Duration 추출 - 우선순위가 높은 패턴 먼저 시도 (VIOLA 방식)
                const patterns = [
                    /총\s*실행시간[:\s]*(\d+초|\d+분\s*\d*초|\d+ms)/i,
                    /총\s*소요시간[:\s]*(\d+초|\d+분\s*\d*초|\d+ms)/i,
                    /fa-play.*?실행시간[:\s]*(\d+초|\d+분\s+\d+초|\d+ms)/i,
                    /meta-item.*?실행시간[:\s]*(\d+초|\d+분\s+\d+초|\d+ms)/i,
                    /실행시간[:\s]*(\d+초|\d+분\s+\d+초)(?!ms)/i,
                    /테스트\s*소요시간[:\s]*(\d+초|\d+분\s*\d*초|\d+ms)/i,
                    /실행\s*소요시간[:\s]*(\d+초|\d+분\s*\d*초|\d+ms)/i,
                    /duration[:\s]*(\d+초|\d+분\s*\d*초|\d+ms)/i
                ];
                
                for (const pattern of patterns) {
                    const match = htmlContent.match(pattern);
                    if (match) {
                        const durationStr = match[1];
                        
                        if (durationStr.includes('분')) {
                            const minutesMatch = durationStr.match(/(\d+)분/);
                            const secondsMatch = durationStr.match(/(\d+)초/);
                            
                            const minutes = minutesMatch ? parseInt(minutesMatch[1]) : 0;
                            const seconds = secondsMatch ? parseInt(secondsMatch[1]) : 0;
                            const totalSeconds = minutes * 60 + seconds;
                            
                            return {
                                duration: totalSeconds,
                                durationText: `${minutes}분 ${seconds}초`,
                                status: status
                            };
                        } else if (durationStr.includes('초')) {
                            const seconds = parseInt(durationStr);
                            const minutes = Math.floor(seconds / 60);
                            const remainingSeconds = seconds % 60;
                            return {
                                duration: seconds,
                                durationText: `${minutes}분 ${remainingSeconds}초`,
                                status: status
                            };
                        }
                    }
                }

                return { duration: 0, durationText: '알 수 없음', status: status };
            } catch (error) {
                console.warn(`⚠️ 리포트 파일 읽기 실패: ${reportPath}`, error);
                return { duration: 0, durationText: '알 수 없음', status: 'completed' };
            }
        }

        // 시나리오 실행 기록 로드
        // 타임스탬프 변환 헬퍼 함수 (2025-10-17T08-10-58 → Date 객체)
        function parseTimestamp(timestamp) {
            try {
                // "2025-10-17T08-10-58" 형식을 "2025-10-17T08:10:58"로 변환
                const normalized = timestamp.replace(/T(\d{2})-(\d{2})-(\d{2})/, 'T$1:$2:$3');
                const date = new Date(normalized);
                
                if (isNaN(date.getTime())) {
                    console.warn(`⚠️ 타임스탬프 파싱 실패: ${timestamp}`);
                    return new Date(); // fallback to current date
                }
                
                return date;
            } catch (error) {
                console.warn(`⚠️ 타임스탬프 파싱 오류: ${timestamp}`, error);
                return new Date();
            }
        }

        async function loadScenarioHistory(scenarioId) {
            // 현재 활성화된 탭에 따라 다른 컨테이너 사용
            const isHistoryTab = document.getElementById('history').classList.contains('active');
            const containerId = isHistoryTab ? `history-content-${scenarioId}` : `scenario-history-content-${scenarioId}`;
            const historyContent = document.getElementById(containerId);
            if (!historyContent) return;
            
            try {
                console.log(`📊 시나리오 ${scenarioId} 기록 로드 시작 (CMP)`);
                
                // 실제 파일 시스템에서 리포트 파일들을 가져오기 (VIOLA 방식)
                const history = await getScenarioHistoryFromFiles(scenarioId);
                console.log(`📊 파일 시스템에서 로드된 기록 수: ${history.length}`);
                
                // 각 기록의 reportPath 확인
                history.forEach((item, index) => {
                    console.log(`📊 기록 ${index + 1}:`, {
                        timestamp: item.timestamp,
                        timestampType: typeof item.timestamp,
                        timestampDate: parseTimestamp(item.timestamp),
                        status: item.status,
                        reportPath: item.reportPath,
                        reportPathType: typeof item.reportPath,
                        hasReportPath: !!item.reportPath
                    });
                });
                
                if (history.length > 0) {
                                    // 저장된 reportPath를 그대로 사용 (이미 올바른 경로가 저장되어 있음)
                const updatedHistory = history.map(item => {
                    console.log(`📊 기록 확인:`, {
                        timestamp: parseTimestamp(item.timestamp).toLocaleString('ko-KR'),
                        status: item.status,
                        reportPath: item.reportPath,
                        hasReportPath: !!item.reportPath,
                        reportPathType: typeof item.reportPath,
                        reportPathLength: item.reportPath ? item.reportPath.length : 0
                    });
                    return item;
                });
                    
                    const historyHtml = updatedHistory.map(item => {
                        // 안전한 날짜 파싱 (VIOLA 방식)
                        let timestamp = 'Invalid Date';
                        try {
                            if (item.formattedTimestamp) {
                                timestamp = item.formattedTimestamp;
                            } else if (item.timestampMs) {
                                const date = new Date(item.timestampMs);
                                if (!isNaN(date.getTime())) {
                                    timestamp = date.toLocaleString('ko-KR');
                                }
                            } else if (item.timestamp) {
                                const date = new Date(item.timestamp);
                                if (!isNaN(date.getTime())) {
                                    timestamp = date.toLocaleString('ko-KR');
                                }
                            }
                        } catch (e) {
                            console.warn('날짜 파싱 오류:', item, e);
                            timestamp = '날짜 파싱 실패';
                        }
                        
                        const statusText = getStatusText(item.status);
                        const statusClass = item.status === 'pass' ? 'success' : 
                                          item.status === 'failed' ? 'error' : 
                                          item.status === 'running' ? 'warning' : 'info';
                        
                        // durationText 우선 사용, 없으면 duration(초) 변환
                        let durationText = 'N/A';
                        if (item.durationText && item.durationText !== 'N/A' && item.durationText !== '알 수 없음') {
                            durationText = item.durationText;
                        } else if (item.duration && typeof item.duration === 'number' && item.duration > 0) {
                            if (item.duration < 60) {
                                durationText = `${item.duration}초`;
                            } else {
                                const minutes = Math.floor(item.duration / 60);
                                const seconds = item.duration % 60;
                                durationText = `${minutes}분 ${seconds}초`;
                            }
                        }
                        
                        return `
                            <div class="history-item">
                                <div class="history-info">
                                    <div class="history-timestamp">
                                        <i class="fas fa-clock"></i>
                                        <span>${timestamp}</span>
                                    </div>
                                    <div class="history-status ${statusClass}">
                                        <i class="fas fa-circle"></i>
                                        <span>${statusText}</span>
                                    </div>
                                    <div class="history-duration">
                                        <i class="fas fa-stopwatch"></i>
                                        <span>${durationText}</span>
                                    </div>
                                </div>
                                <div class="history-actions">
                                    ${item.reportPath ? `
                                        <button class="btn btn-small btn-primary history-report-btn" data-report-path="${item.reportPath}" data-scenario-id="${scenarioId}">
                                            <i class="fas fa-external-link-alt"></i> 리포트 열기
                                    </button>
                                    ` : `
                                        <span class="no-report">리포트 없음</span>
                                    `}
                                </div>
                            </div>
                        `;
                    }).join('');
                    
                    historyContent.innerHTML = historyHtml;
                    
                    // 리포트 열기 버튼에 이벤트 리스너 추가
                    const reportButtons = historyContent.querySelectorAll('.history-report-btn');
                    reportButtons.forEach(button => {
                        button.addEventListener('click', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            
                            const reportPath = this.dataset.reportPath;
                            const scenarioId = parseInt(this.dataset.scenarioId);
                            
                            console.log(`🔍 버튼 클릭 이벤트 발생!`);
                            console.log(`  - 버튼 요소:`, this);
                            console.log(`  - data-report-path:`, reportPath);
                            console.log(`  - data-scenario-id:`, scenarioId);
                            
                            handleHistoryReportClick(reportPath, scenarioId);
                        });
                    });
                    } else {
                    historyContent.innerHTML = `
                        <div class="history-empty">
                            <i class="fas fa-info-circle"></i>
                            <span>아직 실행 기록이 없습니다.</span>
                            </div>
                        `;
                    }
                } catch (error) {
                    console.error('시나리오 기록 로드 중 오류:', error);
                historyContent.innerHTML = `
                    <div class="history-error">
                        <i class="fas fa-exclamation-triangle"></i>
                        <span>기록 로드 중 오류가 발생했습니다.</span>
                        </div>
                    `;
                }
        }
        


        // 이력 관리 탭용 시나리오 기록 토글
        function toggleHistoryScenarioHistory(scenarioId) {
            const scenarioCard = document.querySelector(`#history .scenario-card[data-scenario-id="${scenarioId}"]`);
            if (!scenarioCard) return;
            
            // 기존 기록창이 있는지 확인
            let historyContainer = document.getElementById(`history-scenario-history-${scenarioId}`);
            const isVisible = historyContainer && historyContainer.style.display !== 'none';
            
            if (isVisible) {
                // 기록창 숨기기
                historyContainer.style.display = 'none';
            } else {
                // 기록창이 없으면 생성
                if (!historyContainer) {
                    historyContainer = createHistoryContainer(scenarioId);
                    // 시나리오 카드 다음에 삽입
                    scenarioCard.parentNode.insertBefore(historyContainer, scenarioCard.nextSibling);
                }
                
                historyContainer.style.display = 'block';
                loadScenarioHistory(scenarioId);
            }
        }

        // 이력 관리 탭용 시나리오 로그 토글
        function toggleHistoryScenarioLog(scenarioId) {
            const scenarioCard = document.querySelector(`#history .scenario-card[data-scenario-id="${scenarioId}"]`);
            if (!scenarioCard) return;
            
            // 기존 로그창이 있는지 확인
            let logContainer = document.getElementById(`history-scenario-log-${scenarioId}`);
            const isVisible = logContainer && logContainer.style.display !== 'none';
            
            if (isVisible) {
                // 로그창 숨기기
                logContainer.style.display = 'none';
                } else {
                // 로그창이 없으면 생성
                if (!logContainer) {
                    logContainer = createHistoryLogContainer(scenarioId);
                    // 시나리오 카드 다음에 삽입
                    scenarioCard.parentNode.insertBefore(logContainer, scenarioCard.nextSibling);
                }
                
                logContainer.style.display = 'block';
                updateHistoryScenarioLogView(scenarioId);
            }
        }

        // 이력 관리 탭용 기록창 생성
        function createHistoryContainer(scenarioId) {
            const container = document.createElement('div');
            container.id = `history-scenario-history-${scenarioId}`;
            container.className = 'scenario-history-container';
            container.style.display = 'none';
            
            container.innerHTML = `
                <div class="history-header">
                    <div class="history-title">
                        <i class="fas fa-history"></i>
                        <span>시나리오 ${scenarioId} 실행 기록</span>
                    </div>
                    <button class="history-close-btn" onclick="this.parentElement.parentElement.style.display='none'">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="history-content" id="history-content-${scenarioId}">
                    <div class="history-loading">
                        <i class="fas fa-spinner fa-spin"></i>
                        <span>기록을 불러오는 중...</span>
                    </div>
                </div>
            `;
            
            return container;
        }

        // 이력 관리 탭용 로그창 생성 (단순화된 UI)
        function createHistoryLogContainer(scenarioId) {
            const container = document.createElement('div');
            container.id = `history-scenario-log-${scenarioId}`;
            container.className = 'scenario-log';
            container.style.display = 'none';
            
            // 라이트 모드 클래스 적용
            if (document.body.classList.contains('light-theme')) {
                container.classList.add('light-theme');
            }
            
            container.innerHTML = `
                <div class="log-header" style="
                    background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
                    padding: 20px 25px;
                    border-radius: 12px 12px 0 0;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    border-bottom: none;
                ">
                    <div class="log-title" style="display: flex; align-items: center; font-weight: 600; color: #ffffff;">
                        <i class="fas fa-terminal" style="margin-right: 10px; font-size: 18px; color: #3498db;"></i>
                        <span style="font-size: 16px;">시나리오 ${scenarioId} 실행 로그</span>
                    </div>
                    <div class="log-controls" style="display: flex; gap: 10px;">
                        <button class="btn btn-small btn-primary" onclick="saveScenarioLogsToFile(${scenarioId})" title="로그 저장" style="
                            background: linear-gradient(135deg, #1d80f8 0%, #1565c0 100%);
                            border: none;
                            color: white;
                            padding: 8px 16px;
                            border-radius: 8px;
                            font-size: 13px;
                            font-weight: 500;
                            transition: all 0.3s ease;
                        ">
                            <i class="fas fa-save" style="margin-right: 6px;"></i> 로그 저장
                        </button>
                        <button class="log-close-btn" onclick="this.parentElement.parentElement.parentElement.style.display='none'" style="
                            background: rgba(255, 255, 255, 0.1);
                            border: none;
                            color: white;
                            width: 36px;
                            height: 36px;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            transition: all 0.3s ease;
                            cursor: pointer;
                        ">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
                <div class="log-content" id="history-log-content-${scenarioId}" style="
                    max-height: 300px;
                    overflow-y: auto;
                    background: rgba(255, 255, 255, 0.05);
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    border-radius: 0 0 12px 12px;
                    padding: 15px 15px 15px 10px;
                    font-family: 'Courier New', monospace;
                    font-size: 12px;
                    line-height: 1.4;
                    color: #ffffff;
                ">
                </div>
            `;
            
            return container;
        }

        // 이력 관리 탭용 실시간 로그창 생성
        function createHistoryRealTimeLogContainer(scenarioId) {
            const container = document.createElement('div');
            container.id = `history-scenario-realtime-log-${scenarioId}`;
            container.className = 'scenario-log';
            container.style.display = 'none';
            
            // 라이트 모드 클래스 적용
            if (document.body.classList.contains('light-theme')) {
                container.classList.add('light-theme');
            }
            
            container.innerHTML = `
                <div class="log-header" style="
                    background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
                    padding: 20px 25px;
                    border-radius: 12px 12px 0 0;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    border-bottom: none;
                ">
                    <div class="log-title" style="display: flex; align-items: center; font-weight: 600; color: #ffffff;">
                        <i class="fas fa-stream" style="margin-right: 10px; font-size: 18px; color: #3498db;"></i>
                        <span style="font-size: 16px;">시나리오 ${scenarioId} 실시간 로그</span>
                        <span id="realtime-status-${scenarioId}" style="
                            margin-left: 15px;
                            font-size: 11px;
                            padding: 4px 10px;
                            background: rgba(255, 255, 255, 0.2);
                            border-radius: 12px;
                            display: flex;
                            align-items: center;
                            gap: 5px;
                        ">
                            <span class="status-indicator" style="
                                width: 8px;
                                height: 8px;
                                border-radius: 50%;
                                background: #27ae60;
                                animation: pulse 2s infinite;
                            "></span>
                            대기 중
                        </span>
                    </div>
                    <div class="log-controls" style="display: flex; gap: 10px;">
                        <button class="btn btn-small btn-secondary" onclick="clearRealTimeLogs(${scenarioId})" title="로그 지우기" style="
                            background: rgba(255, 255, 255, 0.2);
                            border: none;
                            color: white;
                            padding: 8px 16px;
                            border-radius: 8px;
                            font-size: 13px;
                            font-weight: 500;
                            transition: all 0.3s ease;
                        ">
                            <i class="fas fa-trash-alt" style="margin-right: 6px;"></i> 지우기
                        </button>
                        <button class="btn btn-small btn-primary" onclick="saveRealTimeLogsToFile(${scenarioId})" title="로그 저장" style="
                            background: linear-gradient(135deg, #1d80f8 0%, #1565c0 100%);
                            border: none;
                            color: white;
                            padding: 8px 16px;
                            border-radius: 8px;
                            font-size: 13px;
                            font-weight: 500;
                            transition: all 0.3s ease;
                        ">
                            <i class="fas fa-save" style="margin-right: 6px;"></i> 로그 저장
                        </button>
                        <button class="log-close-btn" onclick="this.parentElement.parentElement.parentElement.style.display='none'" style="
                            background: rgba(255, 255, 255, 0.1);
                            border: none;
                            color: white;
                            width: 36px;
                            height: 36px;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            transition: all 0.3s ease;
                            cursor: pointer;
                        ">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
                <div class="log-content" id="history-realtime-log-content-${scenarioId}" style="
                    max-height: 500px;
                    overflow-y: auto;
                    background: #1e1e1e;
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    border-radius: 0 0 12px 12px;
                    padding: 15px 15px 15px 10px;
                    font-family: 'Courier New', monospace;
                    font-size: 12px;
                    line-height: 1.6;
                    color: #00ff00;
                ">
                    <div style="text-align: center; padding: 40px 20px; color: rgba(255, 255, 255, 0.4);">
                        <i class="fas fa-hourglass-half" style="font-size: 24px; margin-bottom: 10px; display: block;"></i>
                        <div>시나리오를 실행하면 실시간 로그가 표시됩니다</div>
                        <div style="font-size: 11px; margin-top: 5px;">터미널 출력과 동일한 로그를 실시간으로 보여줍니다</div>
                    </div>
                </div>
            `;
            
            return container;
        }

        // 실시간 로그 토글
        function toggleHistoryScenarioRealTimeLog(scenarioId) {
            const scenarioCard = document.querySelector(`#history .scenario-card[data-scenario-id="${scenarioId}"]`);
            if (!scenarioCard) return;
            
            // 기존 실시간 로그창이 있는지 확인
            let logContainer = document.getElementById(`history-scenario-realtime-log-${scenarioId}`);
            const isVisible = logContainer && logContainer.style.display !== 'none';
            
            if (isVisible) {
                // 로그창 숨기기
                logContainer.style.display = 'none';
            } else {
                // 로그창이 없으면 생성
                if (!logContainer) {
                    logContainer = createHistoryRealTimeLogContainer(scenarioId);
                    // 시나리오 카드 다음에 삽입
                    scenarioCard.parentNode.insertBefore(logContainer, scenarioCard.nextSibling);
                }
                
                logContainer.style.display = 'block';
                updateHistoryScenarioRealTimeLogView(scenarioId);
            }
        }

        // 실시간 로그 뷰 업데이트
        function updateHistoryScenarioRealTimeLogView(scenarioId) {
            console.log(`🔄 [updateHistoryScenarioRealTimeLogView] 호출됨 - 시나리오 ID: ${scenarioId}, 타입: ${typeof scenarioId}`);
            
            const logContent = document.getElementById(`history-realtime-log-content-${scenarioId}`);
            if (!logContent) {
                console.log(`⚠️ [updateHistoryScenarioRealTimeLogView] 로그 컨테이너를 찾을 수 없음: history-realtime-log-content-${scenarioId}`);
                return;
            }
            
            console.log(`✅ [updateHistoryScenarioRealTimeLogView] 로그 컨테이너 발견`);
            
            // 모든 시나리오의 실시간 로그 확인 (디버깅)
            console.log(`🔍 [DEBUG] scenarioRealTimeLogs 전체:`, Object.keys(scenarioRealTimeLogs));
            Object.keys(scenarioRealTimeLogs).forEach(key => {
                console.log(`  - scenarioRealTimeLogs[${key}] (타입: ${typeof key}): ${scenarioRealTimeLogs[key].length}개 로그`);
            });
            
            const logs = scenarioRealTimeLogs[scenarioId] || [];
            console.log(`📊 [updateHistoryScenarioRealTimeLogView] 로그 개수: ${logs.length}`);
            
            // 실시간 로그 상태에 로그 개수 표시 (디버깅)
            const statusElement = document.getElementById(`realtime-status-${scenarioId}`);
            if (statusElement) {
                const currentStatus = statusElement.textContent.trim();
                statusElement.innerHTML = `
                    <span class="status-indicator" style="
                        width: 8px;
                        height: 8px;
                        border-radius: 50%;
                        background: #3498db;
                    "></span>
                    ${logs.length}개 로그
                `;
            }
            
            // 로그가 없으면 안내 메시지 표시
            if (logs.length === 0) {
                console.log(`ℹ️ [updateHistoryScenarioRealTimeLogView] 로그가 없음 - 안내 메시지 표시`);
                logContent.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: rgba(255, 255, 255, 0.4);">
                        <i class="fas fa-hourglass-half" style="font-size: 24px; margin-bottom: 10px; display: block;"></i>
                        <div>시나리오를 실행하면 실시간 로그가 표시됩니다</div>
                        <div style="font-size: 11px; margin-top: 5px;">터미널 출력과 동일한 로그를 실시간으로 보여줍니다</div>
                    </div>
                `;
                return;
            }
            
            console.log(`🎨 [updateHistoryScenarioRealTimeLogView] 로그 렌더링 시작 - ${logs.length}개`);
            
            // 모든 로그를 터미널 스타일로 표시
            logContent.innerHTML = '';
            
            logs.forEach((log, index) => {
                const logLine = document.createElement('div');
                
                // 로그 레벨에 따른 색상 구분
                let logColor = '#e0e0e0'; // 기본 (회색-흰색)
                let bgColor = 'transparent';
                let borderLeft = 'none';
                
                const message = log.message.toLowerCase();
                
                // 로그 타입별 색상 및 강조
                if (message.includes('✅') || message.includes('성공') || message.includes('완료') || message.includes('pass')) {
                    logColor = '#4caf50'; // 녹색
                    borderLeft = '3px solid #4caf50';
                } else if (message.includes('❌') || message.includes('실패') || message.includes('fail') || message.includes('error')) {
                    logColor = '#f44336'; // 빨간색
                    borderLeft = '3px solid #f44336';
                    bgColor = 'rgba(244, 67, 54, 0.1)';
                } else if (message.includes('⚠️') || message.includes('경고') || message.includes('warning')) {
                    logColor = '#ff9800'; // 주황색
                    borderLeft = '3px solid #ff9800';
                } else if (message.includes('🔍') || message.includes('debug')) {
                    logColor = '#2196f3'; // 파란색
                } else if (message.includes('📊') || message.includes('info')) {
                    logColor = '#00bcd4'; // 청록색
                } else if (message.includes('running') || message.includes('실행')) {
                    logColor = '#9c27b0'; // 보라색
                }
                
                // Zebra striping (번갈아 배경색)
                if (index % 2 === 0 && bgColor === 'transparent') {
                    bgColor = 'rgba(255, 255, 255, 0.02)';
                }
                
                logLine.style.cssText = `
                    padding: 8px 12px;
                    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
                    font-size: 13px;
                    line-height: 1.8;
                    color: ${logColor};
                    background: ${bgColor};
                    white-space: pre-wrap;
                    word-break: break-word;
                    border-left: ${borderLeft};
                    margin-bottom: 1px;
                    transition: background 0.2s ease;
                `;
                
                // 호버 효과
                logLine.addEventListener('mouseenter', () => {
                    logLine.style.background = 'rgba(255, 255, 255, 0.08)';
                });
                logLine.addEventListener('mouseleave', () => {
                    logLine.style.background = bgColor;
                });
                
                // 타임스탬프 포함
                const timestamp = new Date(log.timestamp).toLocaleTimeString('ko-KR', { 
                    hour12: false,
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
                
                // 타임스탬프를 어두운 색으로 표시
                logLine.innerHTML = `<span style="color: rgba(255, 255, 255, 0.4); font-weight: 600;">[${timestamp}]</span> ${log.message}`;
                logContent.appendChild(logLine);
                
                if (index === 0 || index === logs.length - 1) {
                    console.log(`📝 [updateHistoryScenarioRealTimeLogView] 로그 ${index + 1}: [${timestamp}] ${log.message.substring(0, 50)}...`);
                }
            });
            
            console.log(`✅ [updateHistoryScenarioRealTimeLogView] 로그 렌더링 완료`);
            
            // 자동 스크롤 (최신 로그로)
            logContent.scrollTop = logContent.scrollHeight;
            console.log(`📜 [updateHistoryScenarioRealTimeLogView] 자동 스크롤 완료 - scrollTop: ${logContent.scrollTop}, scrollHeight: ${logContent.scrollHeight}`);
        }

        // 실시간 로그 지우기
        function clearRealTimeLogs(scenarioId) {
            if (confirm(`시나리오 ${scenarioId}의 실시간 로그를 지우시겠습니까?`)) {
                scenarioRealTimeLogs[scenarioId] = [];
                updateHistoryScenarioRealTimeLogView(scenarioId);
                console.log(`✅ 시나리오 ${scenarioId} 실시간 로그 초기화 완료`);
            }
        }

        // 실시간 로그 파일로 저장
        async function saveRealTimeLogsToFile(scenarioId) {
            if (!scenarioRealTimeLogs[scenarioId] || scenarioRealTimeLogs[scenarioId].length === 0) {
                alert('저장할 실시간 로그가 없습니다.');
                return;
            }

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const fileName = `scenario-${scenarioId}-realtime-logs-${timestamp}.txt`;
            
            let logContent = `=== CMP 시나리오 ${scenarioId} 실시간 로그 ===\n`;
            logContent += `생성 시간: ${new Date().toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' })}\n`;
            logContent += `시나리오 ID: ${scenarioId}\n`;
            logContent += `총 로그 수: ${scenarioRealTimeLogs[scenarioId].length}개\n\n`;
            
            scenarioRealTimeLogs[scenarioId].forEach((log, index) => {
                const logTime = new Date(log.timestamp).toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' });
                logContent += `[${logTime}] ${log.message}\n`;
            });
            
            const blob = new Blob([logContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log(`📄 시나리오 ${scenarioId} 실시간 로그 파일 저장 완료: ${fileName}`);
        }

        // 실시간 로그 추가 함수
        function addRealTimeLog(message, scenarioId) {
            console.log(`🔴 [addRealTimeLog] 호출됨 - 시나리오 ID: ${scenarioId} (타입: ${typeof scenarioId}), 메시지: ${message.substring(0, 50)}...`);
            
            // 해당 시나리오의 실시간 로그 배열 초기화 (없으면)
            if (!scenarioRealTimeLogs[scenarioId]) {
                scenarioRealTimeLogs[scenarioId] = [];
                console.log(`📦 [addRealTimeLog] 시나리오 ${scenarioId} 실시간 로그 배열 생성`);
            }
            
            // 실시간 로그 객체 생성
            const logEntry = {
                timestamp: new Date(),
                message: message
            };
            
            // 로그 추가
            scenarioRealTimeLogs[scenarioId].push(logEntry);
            console.log(`✅ [addRealTimeLog] 로그 추가 완료 - 총 ${scenarioRealTimeLogs[scenarioId].length}개`);
            
            // 실시간 로그 상태 업데이트 (실행 중으로 표시)
            const statusElement = document.getElementById(`realtime-status-${scenarioId}`);
            if (statusElement) {
                statusElement.innerHTML = `
                    <span class="status-indicator" style="
                        width: 8px;
                        height: 8px;
                        border-radius: 50%;
                        background: #e74c3c;
                        animation: pulse 1s infinite;
                    "></span>
                    실행 중
                `;
                console.log(`🔄 [addRealTimeLog] 상태 업데이트 완료: 실행 중`);
            } else {
                console.log(`⚠️ [addRealTimeLog] 상태 요소를 찾을 수 없음: realtime-status-${scenarioId}`);
            }
            
            // 실시간 로그 창이 열려있으면 즉시 UI 업데이트
            const logContent = document.getElementById(`history-realtime-log-content-${scenarioId}`);
            if (logContent) {
                console.log(`🔄 [addRealTimeLog] 실시간 로그 창이 열려있음 - UI 업데이트 시작`);
                updateHistoryScenarioRealTimeLogView(scenarioId);
            } else {
                console.log(`ℹ️ [addRealTimeLog] 실시간 로그 창이 닫혀있음 - UI 업데이트 스킵`);
            }
        }

        // 이력 관리 탭용 로그 뷰 업데이트 (단순화된 텍스트 형태)
        function updateHistoryScenarioLogView(scenarioId) {
            const logContent = document.getElementById(`history-log-content-${scenarioId}`);
            if (!logContent) return;
            
            const logs = scenarioLogs[scenarioId] || [];
            
            // 로그가 없으면 안내 메시지 표시
            if (logs.length === 0) {
                logContent.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: rgba(255, 255, 255, 0.6);">
                        <i class="fas fa-info-circle" style="font-size: 24px; margin-bottom: 10px; display: block;"></i>
                        <div>아직 로그가 없습니다</div>
                        <div style="font-size: 11px; margin-top: 5px;">시나리오를 실행하면 로그가 여기에 표시됩니다</div>
                    </div>
                `;
                return;
            }
            
            // 모든 로그를 단순한 텍스트 형태로 표시
            logContent.innerHTML = '';
            
            logs.forEach((log, index) => {
                // timestamp가 Date 객체인지 확인하고 포맷
                let timestampStr;
                if (log.timestamp instanceof Date) {
                    timestampStr = log.timestamp.toLocaleString('ko-KR');
                } else if (typeof log.timestamp === 'string') {
                    const parsedDate = new Date(log.timestamp);
                    timestampStr = isNaN(parsedDate.getTime()) ? '시간 정보 없음' : parsedDate.toLocaleString('ko-KR');
                } else {
                    timestampStr = '시간 정보 없음';
                }
                
                // 로그 레벨에 따른 색상 설정
                const levelColors = {
                    'info': '#3498db',
                    'success': '#27ae60',
                    'warning': '#f39c12',
                    'error': '#e74c3c'
                };
                
                const levelColor = levelColors[log.level] || '#3498db';
                
                // 단순한 로그 라인 생성
                const logLine = document.createElement('div');
                logLine.style.cssText = `
                    padding: 2px 0;
                    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                    font-family: 'Courier New', monospace;
                    font-size: 12px;
                    line-height: 1.3;
                    word-break: break-word;
                    white-space: normal;
                    margin: 0;
                    text-indent: 0;
                    padding-left: 0;
                    margin-left: 0;
                `;
                
                logLine.innerHTML = `<span style="color: ${levelColor}; font-weight: bold;">[${log.level.toUpperCase()}]</span><span style="color: rgba(255, 255, 255, 0.7); margin-left: 4px;">${timestampStr}</span><span style="color: rgba(255, 255, 255, 0.9); margin-left: 4px;">${log.message}</span>`;
                
                logContent.appendChild(logLine);
            });
            
            // 스크롤을 맨 아래로
            logContent.scrollTop = logContent.scrollHeight;
        }

        // 시나리오 로그 토글
        function toggleScenarioLog(scenarioId) {
            const scenarioCard = document.querySelector(`[data-scenario-id="${scenarioId}"]`);
            if (!scenarioCard) return;
            
            // 기존 로그창이 있는지 확인
            let logContainer = document.getElementById(`scenario-log-${scenarioId}`);
            const isVisible = logContainer && logContainer.style.display !== 'none';
            
            if (isVisible) {
                // 로그창 숨기기
                logContainer.style.display = 'none';
            } else {
                // 로그창이 없으면 생성
                if (!logContainer) {
                    logContainer = createLogContainer(scenarioId);
                    // 시나리오 카드 다음에 삽입
                    scenarioCard.parentNode.insertBefore(logContainer, scenarioCard.nextSibling);
                }
                
                logContainer.style.display = 'block';
                
                // 로그 내용 로드
                const logContent = document.getElementById(`log-content-${scenarioId}`);
                const logs = scenarioLogs[scenarioId] || [];
                
                if (logs.length === 0) {
                    logContent.innerHTML = `
                        <div class="log-entry info">
                            <span class="log-timestamp">[${new Date().toLocaleString('ko-KR')}]</span>
                            이 시나리오의 로그가 없습니다.
                        </div>
                    `;
                    return;
                }

                // 기존 내용 지우기
                logContent.innerHTML = '';
                
                // 로그 엔트리들을 하나씩 추가
                logs.forEach(log => {
                    const logEntry = document.createElement('div');
                    logEntry.className = `log-entry ${log.level}`;
                    logEntry.innerHTML = `
                        <span class="log-timestamp">[${log.timestamp}]</span>
                        ${log.message}
                    `;
                    logContent.appendChild(logEntry);
                });
                
                // 스크롤을 맨 아래로
                logContent.scrollTop = logContent.scrollHeight;
            }
        }

        // 로그창 컨테이너 생성
        function createLogContainer(scenarioId) {
            const logContainer = document.createElement('div');
            logContainer.id = `scenario-log-${scenarioId}`;
            logContainer.className = 'scenario-log-container';
            logContainer.style.display = 'none';
            
            logContainer.innerHTML = `
                <div class="log-header">
                    <div class="log-title">
                        <i class="fas fa-terminal"></i>
                        <span>시나리오 ${scenarioId} 로그</span>
                    </div>
                    <button class="log-close-btn" onclick="toggleScenarioLog(${scenarioId}); event.stopPropagation();">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="log-content" id="scenario-log-content-${scenarioId}">
                    <!-- 로그 내용이 여기에 표시됩니다 -->
                </div>
            `;
            
            return logContainer;
        }

        // 로그 타입별 색상 반환
        function getLogColor(type) {
            switch (type) {
                case 'info': return '#3498db';
                case 'success': return '#27ae60';
                case 'warning': return '#f39c12';
                case 'error': return '#e74c3c';
                default: return '#95a5a6';
            }
        }
        
        // 시나리오 상태 저장
        function saveScenarioStatus() {
            try {
                const statusData = {};
                scenarios.forEach(scenario => {
                    statusData[scenario.id] = scenario.status;
                });
                localStorage.setItem('cmp-scenarioStatusData', JSON.stringify(statusData));
                console.log('📊 시나리오 상태 저장 완료:', statusData);
            } catch (error) {
                console.error('시나리오 상태 저장 실패:', error);
            }
        }

        // 시나리오 상태 로드
        function loadScenarioStatus() {
            try {
                const savedData = localStorage.getItem('cmp-scenarioStatusData');
                if (savedData) {
                    const statusData = JSON.parse(savedData);
                    scenarios.forEach(scenario => {
                        if (statusData[scenario.id]) {
                            scenario.status = statusData[scenario.id];
                        }
                    });
                    console.log('📊 시나리오 상태 로드 완료:', statusData);
                }
            } catch (error) {
                console.error('시나리오 상태 로드 실패:', error);
            }
        }

        // 전체 시나리오 초기화
        async function resetAllScenarios() {
            if (!await showConfirmDialog('전체 초기화', '모든 시나리오의 상태를 \'미실행\'으로 초기화하시겠습니까?', '이 작업은 되돌릴 수 없습니다.')) {
                return;
            }
            
            try {
                // 모든 시나리오 상태를 'ready'로 변경
                scenarios.forEach(scenario => {
                    scenario.status = 'ready';
                    
                    // 시나리오 카드 즉시 업데이트 (메모리 상태 기반)
                    const card = document.querySelector(`#scenarios [data-scenario-id="${scenario.id}"]`);
                    if (card) {
                        card.className = `scenario-card ready`;
                        const statusBadge = card.querySelector('.status-badge');
                        if (statusBadge) {
                            statusBadge.className = `status-badge ready`;
                            statusBadge.textContent = '미실행';
                        }
                    }
                });
                
                // 상태 저장
                saveScenarioStatus();
                
                // 실행/중단 버튼 UI 업데이트
                updateRunStopButtonsUI();
                
                // 요약 카드 업데이트
                createSummaryCards();
                createSummaryCardsForHistory();
                
                // 로그 추가
                addLog('모든 시나리오 상태가 초기화되었습니다.', 'info');
                showToast('모든 시나리오 상태가 초기화되었습니다.', 'success');
                
                console.log('📊 전체 시나리오 초기화 완료');
            } catch (error) {
                console.error('전체 시나리오 초기화 중 오류:', error);
                showToast('전체 시나리오 초기화 중 오류가 발생했습니다.', 'error');
            }
        }

        // 선택된 시나리오 일괄 삭제
        async function deleteSelectedScenarios() {
            if (selectedScenarios.length === 0) {
                showToast('삭제할 시나리오를 선택하세요.', 'warning');
                return;
            }
            
            if (!await showConfirmDialog(
                '선택 시나리오 삭제', 
                `선택한 ${selectedScenarios.length}개의 시나리오를 삭제하시겠습니까?\n`,
                '계속하시겠습니까?'
            )) {
                return;
            }
            
            try {
                let successCount = 0;
                let failCount = 0;
                
                // 각 시나리오 삭제
                for (const scenarioId of selectedScenarios) {
                    try {
                        const result = await ipcRenderer.invoke('delete-scenario', scenarioId);
                        
                        if (result.success) {
                            successCount++;
                            
                            // 메모리에서 시나리오 제거
                            const index = scenarios.findIndex(s => s.id === scenarioId);
                            if (index !== -1) {
                                scenarios.splice(index, 1);
                            }
                            
                            // UI에서 카드 제거
                            const card = document.querySelector(`[data-scenario-id="${scenarioId}"]`);
                            if (card) {
                                card.remove();
                            }
                            
                            addLog(`시나리오 ${scenarioId} 삭제 완료`, 'info');
                        } else {
                            failCount++;
                            addLog(`시나리오 ${scenarioId} 삭제 실패: ${result.error}`, 'error');
                        }
                    } catch (error) {
                        failCount++;
                        console.error(`시나리오 ${scenarioId} 삭제 중 오류:`, error);
                        addLog(`시나리오 ${scenarioId} 삭제 중 오류: ${error.message}`, 'error');
                    }
                }
                
                // 선택 초기화
                selectedScenarios = [];
                document.querySelectorAll('.scenario-checkbox-input:checked').forEach(checkbox => {
                    checkbox.checked = false;
                });
                
                // 요약 카드 업데이트
                createSummaryCards();
                createSummaryCardsForHistory();
                
                // 선택된 시나리오 목록 업데이트
                updateSelectedScenarios();
                
                // 결과 메시지
                if (successCount > 0) {
                    showToast(`${successCount}개 시나리오 삭제 완료${failCount > 0 ? `, ${failCount}개 실패` : ''}`, 'success');
                } else {
                    showToast(`모든 시나리오 삭제 실패 (${failCount}개)`, 'error');
                }
            } catch (error) {
                console.error('시나리오 일괄 삭제 중 오류:', error);
                showToast('시나리오 삭제 중 오류가 발생했습니다.', 'error');
            }
        }

        // 예쁜 확인 팝업 표시
        function showConfirmDialog(title, message, warning = '') {
            return new Promise((resolve) => {
                // 기존 팝업이 있다면 제거
                const existingPopup = document.getElementById('confirmDialog');
                if (existingPopup) {
                    existingPopup.remove();
                }

                // 팝업 오버레이 생성
                const overlay = document.createElement('div');
                overlay.id = 'confirmDialog';
                overlay.className = 'confirm-dialog-overlay';
                overlay.innerHTML = `
                    <div class="confirm-dialog">
                        <div class="confirm-dialog-header">
                            <div class="confirm-dialog-icon">
                                <i class="fas fa-exclamation-triangle"></i>
                            </div>
                            <h3>${title}</h3>
                        </div>
                        <div class="confirm-dialog-content">
                            <p>${message}</p>
                            ${warning ? `<p class="confirm-dialog-warning">${warning}</p>` : ''}
                        </div>
                        <div class="confirm-dialog-actions">
                            <button class="confirm-dialog-btn confirm-dialog-cancel" onclick="closeConfirmDialog(false)">
                                <i class="fas fa-times"></i>
                                취소
                            </button>
                            <button class="confirm-dialog-btn confirm-dialog-confirm" onclick="closeConfirmDialog(true)">
                                <i class="fas fa-check"></i>
                                확인
                            </button>
                        </div>
                    </div>
                `;

                document.body.appendChild(overlay);

                // 애니메이션 효과
                setTimeout(() => {
                    overlay.classList.add('show');
                }, 10);

                // 전역 함수로 결과 저장
                window.confirmDialogResult = null;
                window.closeConfirmDialog = (result) => {
                    window.confirmDialogResult = result;
                    overlay.classList.remove('show');
                    setTimeout(() => {
                        overlay.remove();
                        resolve(result);
                    }, 300);
                };

                // ESC 키로 취소
                const handleEsc = (e) => {
                    if (e.key === 'Escape') {
                        window.closeConfirmDialog(false);
                        document.removeEventListener('keydown', handleEsc);
                    }
                };
                document.addEventListener('keydown', handleEsc);

                // 오버레이 클릭으로 취소
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        window.closeConfirmDialog(false);
                    }
                });
            });
        }
        
        // 시나리오 상태 초기화
        async function resetScenarioStatus(scenarioId) {
            if (!await showConfirmDialog('시나리오 초기화', `시나리오 ${scenarioId}의 상태를 '미실행'으로 초기화하시겠습니까?`)) {
                return;
            }
            
            try {
                const result = await ipcRenderer.invoke('reset-scenario-status', scenarioId);
                
                if (result.success) {
                    // UI 업데이트
                    const scenario = scenarios.find(s => s.id === scenarioId);
                    if (scenario) {
                        scenario.status = 'ready';
                        
                        // 시나리오 카드 즉시 업데이트 (메모리 상태 기반)
                        const card = document.querySelector(`#scenarios [data-scenario-id="${scenarioId}"]`);
                        if (card) {
                            card.className = `scenario-card ready`;
                            const statusBadge = card.querySelector('.status-badge');
                            if (statusBadge) {
                                statusBadge.className = `status-badge ready`;
                                statusBadge.textContent = '미실행';
                            }
                        }
                        
                        // 실행/중단 버튼 UI 업데이트
                        updateRunStopButtonsUI();
                        
                        createSummaryCards(); // 요약 카드 업데이트
                        saveScenarioStatus(); // 상태 변경 후 저장
                    }
                    
                    showToast(`시나리오 ${scenarioId} 상태가 초기화되었습니다.`, 'success');
                    addLog(`시나리오 ${scenarioId} 상태 초기화 완료`, 'info');
                } else {
                    showToast('상태 초기화 실패: ' + result.error, 'error');
                }
            } catch (error) {
                console.error('시나리오 상태 초기화 중 오류:', error);
                showToast('시나리오 상태 초기화 중 오류가 발생했습니다.', 'error');
            }
        }

        // 제품 선택 화면으로 돌아가기
        function goBackToProductSelector() {
            const { ipcRenderer } = require('electron');
            ipcRenderer.send('go-back-to-product-selector');
        }

        // CMP 전용 설정
        const PRODUCT_NAME = 'CMP';
        const PRODUCT_PATH = './';
        const REPORTS_PATH = './reports/html/';
        
        // 제품별 독립적인 데이터 관리
        const PRODUCT_DATA_KEY = 'cmp_test_results';
        const PRODUCT_SCENARIOS_KEY = 'cmp_scenarios';

        // 탭 전환
        function switchTab(tabName, event) {
            // 모든 탭 비활성화
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });

            // 선택된 탭 활성화
            document.getElementById(tabName).classList.add('active');
            if (event && event.currentTarget) {
            event.currentTarget.classList.add('active');
            }
            
            // 이력 관리 탭인 경우 초기화
            if (tabName === 'history') {
                console.log('이력 관리 탭으로 전환, initializeHistoryTab 호출');
                initializeHistoryTab();
            }
        }

        // 코드 생성 화면으로 이동
        function navigateToCodegen(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            console.log('🎬 코드 생성 화면으로 이동 중...');
            
            // 현재 페이지를 코드 생성 GUI로 전환 (제품 정보와 돌아올 경로 전달)
            const codegenPath = '../autoscript/electron-codegen-gui/renderer/index.html?product=cmp&from=cmp-main';
            window.location.href = codegenPath;
        }

        // 마스터 리포트 열기
        async function openMasterReport() {
            try {
                console.log('마스터 리포트 열기 요청');
                const result = await ipcRenderer.invoke('open-master-report');
                
                if (result.success) {
                    console.log('마스터 리포트 열기 성공:', result.path);
                    showToast('마스터 리포트가 브라우저에서 열렸습니다.', 'success');
                } else {
                    console.error('마스터 리포트 열기 실패:', result.error);
                    showToast(`마스터 리포트 열기 실패: ${result.error}`, 'error');
                }
            } catch (error) {
                console.error('마스터 리포트 열기 중 오류:', error);
                showToast('마스터 리포트 열기 중 오류가 발생했습니다.', 'error');
            }
        }

        // 버튼 상태 변경 함수
        function updateScenarioButtons(scenarioId, isRunning) {
            const runBtnElement = document.getElementById(`run-btn-${scenarioId}`);
            const stopBtnElement = document.getElementById(`stop-btn-${scenarioId}`);
            
            if (isRunning) {
                if (runBtnElement) runBtnElement.style.display = 'none';
                if (stopBtnElement) stopBtnElement.style.display = 'inline-block';
            } else {
                if (runBtnElement) runBtnElement.style.display = 'inline-block';
                if (stopBtnElement) stopBtnElement.style.display = 'none';
            }
        }

        // 시나리오 중단
        async function stopScenario(scenarioId) {
            console.log('중단 버튼 클릭됨, 시나리오:', scenarioId, '현재 실행 중인 시나리오들:', Array.from(currentRunningScenarioIds));
            
            if (!currentRunningScenarioIds.has(scenarioId)) {
                console.log('해당 시나리오가 실행 중이 아닙니다.');
                return;
            }
            
            try {
                console.log(`🔄 시나리오 ${scenarioId} 중단 요청`);
                const result = await ipcRenderer.invoke('stop-specific-test', `scenario-${scenarioId}`);
                
                if (result.success) {
                    console.log(`🔄 시나리오 ${scenarioId} 중단 성공`);
                    addLog(`시나리오 ${scenarioId} 테스트가 중단되었습니다.`, 'warning', scenarioId);
                    
                    // 중단된 시나리오를 실패로 처리
                    const scenario = scenarios.find(s => s.id === scenarioId);
                    if (scenario) {
                        scenario.status = 'fail';
                        updateScenarioCard(scenarioId);
                    }
                    
                    updateScenarioButtons(scenarioId, false);
                    currentRunningScenarioIds.delete(scenarioId);
                } else {
                    console.log(`❌ 시나리오 ${scenarioId} 중단 실패:`, result.error);
                    addLog(`시나리오 ${scenarioId} 중단 중 오류가 발생했습니다: ${result.error}`, 'error', scenarioId);
                }
            } catch (error) {
                console.error(`❌ 시나리오 ${scenarioId} 중단 중 오류:`, error);
                addLog(`시나리오 ${scenarioId} 중단 중 오류가 발생했습니다: ${error.message}`, 'error', scenarioId);
            }
        }

        // 시나리오 실행
        async function runScenario(scenarioId) {
            console.log(`runScenario 함수 호출됨 - 시나리오 ID: ${scenarioId}`);
            
            // 새로운 시나리오 실행 시 실행 로그 리셋
            resetExecutionLogs();
            
            // 시나리오 ID를 숫자로 변환하여 찾기
            const numericScenarioId = parseInt(scenarioId);
            const scenario = scenarios.find(s => s.id === numericScenarioId);
            if (!scenario) {
                console.error(`시나리오 ${scenarioId}를 찾을 수 없습니다.`);
                console.error(`scenarios 배열:`, scenarios.map(s => ({ id: s.id, title: s.title })));
                return;
            }

            console.log(`시나리오 정보:`, scenario);

            // 실시간 로그 초기화
            scenarioRealTimeLogs[numericScenarioId] = [];
            console.log(`🧹 시나리오 ${numericScenarioId} 실시간 로그 초기화 완료`);
            
            // 실시간 로그 UI 초기화 (화면에 표시된 로그도 지우기)
            const realtimeLogContainer = document.getElementById(`history-scenario-realtime-log-${numericScenarioId}`);
            if (realtimeLogContainer) {
                updateHistoryScenarioRealTimeLogView(numericScenarioId);
            }
            
            // 실시간 로그 상태 업데이트 (대기 중으로 표시)
            const statusElement = document.getElementById(`realtime-status-${numericScenarioId}`);
            if (statusElement) {
                statusElement.innerHTML = `
                    <span class="status-indicator" style="
                        width: 8px;
                        height: 8px;
                        border-radius: 50%;
                        background: #f39c12;
                        animation: pulse 1s infinite;
                    "></span>
                    시작 중
                `;
            }

            // 실행 시작 시간 기록
            const startTime = new Date();
            const startTimestamp = startTime.getTime();

            // 상태 업데이트
            scenario.status = 'running';
            updateScenarioCard(scenarioId);
            updateScenarioButtons(scenarioId, true);
            updateRecordingButtonsUI(); // 녹화 버튼 UI 업데이트
            saveScenarioStatus(); // 상태 저장

            // 현재 실행 중인 시나리오 ID를 즉시 추가 (Playwright 로그 수신을 위해)
            const runningScenarioId = parseInt(scenarioId);
            currentRunningScenarioIds.add(runningScenarioId);
            console.log(`🔍 시나리오 ${runningScenarioId}를 실행 중인 시나리오 목록에 즉시 추가했습니다.`);
            console.log(`🔍 현재 실행 중인 시나리오들:`, Array.from(currentRunningScenarioIds));
            
            // 이력 관리 탭에서 해당 시나리오의 로그 창을 미리 생성 (자동으로 열지 않음)
            const scenarioCard = document.querySelector(`#history .scenario-card[data-scenario-id="${runningScenarioId}"]`);
            if (scenarioCard) {
                let logContainer = document.getElementById(`history-scenario-log-${runningScenarioId}`);
                if (!logContainer) {
                    logContainer = createHistoryLogContainer(runningScenarioId);
                    scenarioCard.parentNode.insertBefore(logContainer, scenarioCard.nextSibling);
                }
                // ⚠️ 자동 포커싱 제거 - 사용자가 버튼을 클릭해야 열림
                // logContainer.style.display = 'block';
                
                // 실시간 로그 컨테이너도 미리 생성 (자동으로 열지 않음)
                let realtimeLogContainer = document.getElementById(`history-scenario-realtime-log-${runningScenarioId}`);
                if (!realtimeLogContainer) {
                    realtimeLogContainer = createHistoryRealTimeLogContainer(runningScenarioId);
                    scenarioCard.parentNode.insertBefore(realtimeLogContainer, scenarioCard.nextSibling);
                    console.log(`✅ 시나리오 ${runningScenarioId} 실시간 로그 컨테이너 미리 생성 완료`);
                }
                // ⚠️ 자동 포커싱 제거 - 사용자가 '실시간 로그' 버튼을 클릭해야 열림
                // realtimeLogContainer.style.display = 'block';
            }
            
            // 실행 시작 로그 추가 (addDirectLog 사용)
            addDirectLog(`시나리오 ${scenarioId}: ${scenario.title} 실행을 시작합니다.`, 'info', runningScenarioId);
            addDirectLog(`시나리오 ${scenarioId}: 테스트 환경 초기화 중...`, 'info', runningScenarioId);
            addDirectLog(`시나리오 ${scenarioId}: Playwright 테스트 실행 준비 중...`, 'info', runningScenarioId);
            
            // 버튼 상태 업데이트
            updateSelectedScenarios();

            try {
                console.log(`ipcRenderer.invoke 호출 시작 - testType: scenario-${scenarioId}`);
                addDirectLog(`시나리오 ${scenarioId}: IPC 통신 시작 - 테스트 실행 요청`, 'info', scenarioId);
                
                // 실제 테스트 실행 (현재는 trombone-main.spec.js 기반)
                addDirectLog(`시나리오 ${scenarioId}: 테스트 실행 중... (최대 16분 40초 대기)`, 'info', scenarioId);
                
                // 실제 테스트 실행
                const result = await Promise.race([
                    ipcRenderer.invoke('run-test', `scenario-${scenarioId}`),
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('테스트 실행 시간 초과')), 300000) // 5분 타임아웃
                    )
                ]);
                
                // 결과 로그 추가
                if (result.success) {
                    addDirectLog(`시나리오 ${scenarioId}: 테스트 실행 성공`, 'success', scenarioId);
                } else {
                    addDirectLog(`시나리오 ${scenarioId}: 테스트 실행 실패 - ${result.error || '알 수 없는 오류'}`, 'error', scenarioId);
                }
                
                console.log(`ipcRenderer.invoke 결과:`, result);
                console.log(`📊 [DEBUG] result.success: ${result.success}`);
                console.log(`📊 [DEBUG] result.code: ${result.code}`);
                console.log(`📊 [DEBUG] result.signal: ${result.signal}`);
                
                // 실행 종료 시간 및 소요시간 계산
                const endTime = new Date();
                const endTimestamp = endTime.getTime();
                const duration = Math.round((endTimestamp - startTimestamp) / 1000); // 초 단위
                
                if (result.success) {
                    addLog(`시나리오 ${scenarioId}: 테스트 실행 완료 - 결과 처리 중...`, 'info', scenarioId);
                    scenario.status = 'pass';
                    currentRunningScenarioIds.delete(scenarioId); // 즉시 제거하여 test-pass 이벤트가 중복 처리하지 않도록
                    
                    // 실시간 로그 상태 업데이트 (완료 - 성공)
                    const statusElement = document.getElementById(`realtime-status-${scenarioId}`);
                    if (statusElement) {
                        statusElement.innerHTML = `
                            <span class="status-indicator" style="
                                width: 8px;
                                height: 8px;
                                border-radius: 50%;
                                background: #27ae60;
                            "></span>
                            완료 (성공)
                        `;
                    }
                    
                    // 시나리오 목록 탭의 카드 즉시 업데이트 (메모리 상태 기반)
                    const card = document.querySelector(`#scenarios [data-scenario-id="${scenarioId}"]`);
                    if (card) {
                        card.className = `scenario-card pass`;
                        const statusBadge = card.querySelector('.status-badge');
                        if (statusBadge) {
                            statusBadge.className = `status-badge pass`;
                            statusBadge.textContent = '성공';
                        }
                    }
                    
                    // 실행/중단 버튼 UI 업데이트
                    updateRunStopButtonsUI();
                    
                    // 녹화 버튼 UI 업데이트
                    updateRecordingButtonsUI();
                    
                    // 요약 카드 업데이트
                    createSummaryCards();
                    createSummaryCardsForHistory();
                    
                    saveScenarioStatus(); // 상태 저장
                    addLog(`시나리오 ${scenarioId}: ${scenario.title} 실행이 성공적으로 완료되었습니다. (소요시간: ${duration}초)`, 'success', scenarioId);
                    
                    // 레포트 정보 업데이트
                    addLog(`시나리오 ${scenarioId}: 레포트 정보 업데이트 중...`, 'info', scenarioId);
                    scenarioReports[scenarioId] = {
                        status: 'completed',
                        lastRun: endTime.toISOString(),
                        reportUrl: `playwright-report/scenario-${scenarioId}/index.html`
                    };
                    
                    // 커스텀 리포트 생성 및 경로 가져오기
                    addLog(`시나리오 ${scenarioId}: 커스텀 리포트 생성 중...`, 'info', scenarioId);
                    const reportResult = await ipcRenderer.invoke('generate-custom-report', scenarioId);
                    const reportPath = reportResult.success ? reportResult.path : null;
                    
                    // 실행 기록 저장 (커스텀 리포트 경로 포함)
                    addLog(`시나리오 ${scenarioId}: 실행 기록 저장 중...`, 'info', scenarioId);
                    console.log(`📊 저장할 실행 기록 데이터:`, {
                        timestamp: startTimestamp,
                        startTime: startTime.toISOString(),
                        endTime: endTime.toISOString(),
                        duration: duration,
                        status: 'completed',
                        reportPath: reportPath
                    });
                    saveScenarioHistory(scenarioId, {
                        timestamp: startTimestamp,
                        startTime: startTime.toISOString(),
                        endTime: endTime.toISOString(),
                        duration: duration,
                        status: 'completed',
                        reportPath: reportPath // 커스텀 리포트 경로 바로 설정
                    });
                    
                    // 이력 관리 탭의 카드도 즉시 업데이트
                    const historyCard = document.querySelector(`#history [data-scenario-id="${scenarioId}"]`);
                    if (historyCard) {
                        historyCard.className = `scenario-card completed`;
                        const historyStatusBadge = historyCard.querySelector('.status-badge');
                        if (historyStatusBadge) {
                            historyStatusBadge.className = `status-badge completed`;
                            historyStatusBadge.textContent = '성공';
                        }
                        console.log(`✅ 이력 관리 탭 카드 업데이트 완료: completed`);
                    }
                    
                    if (reportPath) {
                        addLog(`시나리오 ${scenarioId}: 커스텀 리포트 생성 완료 - ${reportPath}`, 'success', scenarioId);
                        console.log(`✅ 커스텀 리포트 경로: ${reportPath}`);
                    } else {
                        addLog(`시나리오 ${scenarioId}: 커스텀 리포트 생성 실패`, 'warning', scenarioId);
                        console.log(`❌ 커스텀 리포트 생성 실패`);
                    }
                    
                    // 레포트 새로고침 (약간의 지연 후)
                    addLog(`시나리오 ${scenarioId}: 레포트 새로고침 예약 (1초 후)...`, 'info', scenarioId);
                    setTimeout(() => {
                        refreshReport(scenarioId);
                    }, 1000);
                } else {
                    addLog(`시나리오 ${scenarioId}: 테스트 실행 실패 - 오류 처리 중...`, 'warning', scenarioId);
                    scenario.status = 'fail';
                    currentRunningScenarioIds.delete(scenarioId); // 즉시 제거하여 test-failed 이벤트가 중복 처리하지 않도록
                    
                    // 실시간 로그 상태 업데이트 (완료 - 실패)
                    const statusElement = document.getElementById(`realtime-status-${scenarioId}`);
                    if (statusElement) {
                        statusElement.innerHTML = `
                            <span class="status-indicator" style="
                                width: 8px;
                                height: 8px;
                                border-radius: 50%;
                                background: #e74c3c;
                            "></span>
                            완료 (실패)
                        `;
                    }
                    
                    // 시나리오 목록 탭의 카드 즉시 업데이트 (메모리 상태 기반)
                    const card = document.querySelector(`#scenarios [data-scenario-id="${scenarioId}"]`);
                    if (card) {
                        card.className = `scenario-card fail`;
                        const statusBadge = card.querySelector('.status-badge');
                        if (statusBadge) {
                            statusBadge.className = `status-badge fail`;
                            statusBadge.textContent = '실패';
                        }
                    }
                    
                    // 실행/중단 버튼 UI 업데이트
                    updateRunStopButtonsUI();
                    
                    // 녹화 버튼 UI 업데이트
                    updateRecordingButtonsUI();
                    
                    // 요약 카드 업데이트
                    createSummaryCards();
                    createSummaryCardsForHistory();
                    
                    saveScenarioStatus(); // 상태 저장
                    addLog(`시나리오 ${scenarioId}: ${scenario.title} 실행 중 오류가 발생했습니다. (소요시간: ${duration}초) - ${result.error || '알 수 없는 오류'}`, 'error', scenarioId);
                    
                    // 레포트 정보 업데이트
                    addLog(`시나리오 ${scenarioId}: 실패 상태 레포트 정보 업데이트 중...`, 'info', scenarioId);
                    scenarioReports[scenarioId] = {
                        status: 'failed',
                        lastRun: endTime.toISOString(),
                        reportUrl: `playwright-report/scenario-${scenarioId}/index.html`
                    };
                    
                    // 커스텀 리포트 생성 및 경로 가져오기 (실패 케이스)
                    addLog(`시나리오 ${scenarioId}: 실패 케이스 커스텀 리포트 생성 중...`, 'info', scenarioId);
                    const reportResult = await ipcRenderer.invoke('generate-custom-report', scenarioId);
                    const reportPath = reportResult.success ? reportResult.path : null;
                    
                    // 실행 기록 저장 (커스텀 리포트 경로 포함)
                    addLog(`시나리오 ${scenarioId}: 실패 케이스 실행 기록 저장 중...`, 'info', scenarioId);
                    console.log(`📊 저장할 실패 케이스 실행 기록 데이터:`, {
                        timestamp: startTimestamp,
                        startTime: startTime.toISOString(),
                        endTime: endTime.toISOString(),
                        duration: duration,
                        status: 'failed',
                        reportPath: reportPath
                    });
                    saveScenarioHistory(scenarioId, {
                        timestamp: startTimestamp,
                        startTime: startTime.toISOString(),
                        endTime: endTime.toISOString(),
                        duration: duration,
                        status: 'failed',
                        reportPath: reportPath // 커스텀 리포트 경로 바로 설정
                    });
                    
                    // 이력 관리 탭의 카드도 즉시 업데이트
                    const historyCard = document.querySelector(`#history [data-scenario-id="${scenarioId}"]`);
                    if (historyCard) {
                        historyCard.className = `scenario-card failed`;
                        const historyStatusBadge = historyCard.querySelector('.status-badge');
                        if (historyStatusBadge) {
                            historyStatusBadge.className = `status-badge failed`;
                            historyStatusBadge.textContent = '실패';
                        }
                        console.log(`✅ 이력 관리 탭 카드 업데이트 완료: failed`);
                    }
                    
                    if (reportPath) {
                        addLog(`시나리오 ${scenarioId}: 실패 케이스 커스텀 리포트 생성 완료 - ${reportPath}`, 'success', scenarioId);
                        console.log(`✅ 실패 케이스 커스텀 리포트 경로: ${reportPath}`);
                    } else {
                        addLog(`시나리오 ${scenarioId}: 실패 케이스 커스텀 리포트 생성 실패`, 'warning', scenarioId);
                        console.log(`❌ 실패 케이스 커스텀 리포트 생성 실패`);
                    }
                    
                    // 레포트 새로고침 (약간의 지연 후)
                    addLog(`시나리오 ${scenarioId}: 실패 케이스 레포트 새로고침 예약 (1초 후)...`, 'info', scenarioId);
                    setTimeout(() => {
                        refreshReport(scenarioId);
                    }, 1000);
                }
            } catch (error) {
                addLog(`시나리오 ${scenarioId}: 예외 발생 - 오류 처리 중...`, 'warning', scenarioId);
                
                // 이미 성공 처리된 경우 (리포트 생성 중 에러), 실패로 변경하지 않음
                if (scenario.status === 'pass') {
                    console.log(`✅ 시나리오 ${scenarioId}는 이미 성공 처리되었으므로 예외를 무시합니다.`);
                    addLog(`시나리오 ${scenarioId}: 테스트는 성공했으나 후처리 중 예외 발생 - ${error.message}`, 'warning', scenarioId);
                    return;
                }
                
                // 실행 종료 시간 및 소요시간 계산
                const endTime = new Date();
                const endTimestamp = endTime.getTime();
                const duration = Math.round((endTimestamp - startTimestamp) / 1000); // 초 단위
                
                scenario.status = 'fail';
                currentRunningScenarioIds.delete(scenarioId); // 즉시 제거하여 test-failed 이벤트가 중복 처리하지 않도록
                
                // 시나리오 목록 탭의 카드 즉시 업데이트 (메모리 상태 기반)
                const card = document.querySelector(`#scenarios [data-scenario-id="${scenarioId}"]`);
                if (card) {
                    card.className = `scenario-card fail`;
                    const statusBadge = card.querySelector('.status-badge');
                    if (statusBadge) {
                        statusBadge.className = `status-badge fail`;
                        statusBadge.textContent = '실패';
                    }
                }
                
                // 실행/중단 버튼 UI 업데이트
                updateRunStopButtonsUI();
                
                // 녹화 버튼 UI 업데이트
                updateRecordingButtonsUI();
                
                // 요약 카드 업데이트
                createSummaryCards();
                createSummaryCardsForHistory();
                
                saveScenarioStatus(); // 상태 저장
                addLog(`시나리오 ${scenarioId}: ${scenario.title} 실행 중 예외가 발생했습니다. (소요시간: ${duration}초) - ${error.message}`, 'error', scenarioId);
                
                // 레포트 정보 업데이트
                addLog(`시나리오 ${scenarioId}: 예외 케이스 레포트 정보 업데이트 중...`, 'info', scenarioId);
                scenarioReports[scenarioId] = {
                    status: 'failed',
                    lastRun: endTime.toISOString(),
                    reportUrl: null
                };
                
                // 실행 기록 저장
                addLog(`시나리오 ${scenarioId}: 예외 케이스 실행 기록 저장 중...`, 'info', scenarioId);
                saveScenarioHistory(scenarioId, {
                    timestamp: startTimestamp,
                    startTime: startTime.toISOString(),
                    endTime: endTime.toISOString(),
                    duration: duration,
                    status: 'failed',
                    reportPath: null
                });
                
                // 이력 관리 탭의 카드도 즉시 업데이트
                const historyCard = document.querySelector(`#history [data-scenario-id="${scenarioId}"]`);
                if (historyCard) {
                    historyCard.className = `scenario-card failed`;
                    const historyStatusBadge = historyCard.querySelector('.status-badge');
                    if (historyStatusBadge) {
                        historyStatusBadge.className = `status-badge failed`;
                        historyStatusBadge.textContent = '실패';
                    }
                    console.log(`✅ 이력 관리 탭 카드 업데이트 완료: failed (예외)`);
                }
            }

            // 정리 작업 (currentRunningScenarioIds는 이미 제거됨)
            addLog(`시나리오 ${scenarioId}: 실행 완료 - 정리 작업 중...`, 'info', scenarioId);
            updateScenarioButtons(scenarioId, false);
            updateScenarioCard(scenarioId); // 시나리오 카드 UI 업데이트
            
            // 버튼 상태 업데이트
            updateSelectedScenarios();
            addLog(`시나리오 ${scenarioId}: 모든 정리 작업 완료`, 'success', scenarioId);
        }

        // 시나리오 카드 업데이트 (메모리 상태 직접 사용)
        function updateScenarioCard(scenarioId) {
            const scenario = scenarios.find(s => s.id === scenarioId);
            if (!scenario) return;

            console.log(`🔄 시나리오 ${scenarioId} 카드 업데이트: ${scenario.status}`);

            // 시나리오 목록 탭의 카드 업데이트
            const card = document.querySelector(`#scenarios [data-scenario-id="${scenarioId}"]`);
            if (card) {
                card.className = `scenario-card ${scenario.status}`;
                const statusBadge = card.querySelector('.status-badge');
                if (statusBadge) {
                    statusBadge.className = `status-badge ${scenario.status}`;
                    statusBadge.textContent = getStatusText(scenario.status);
                }
            }
            
            // 이력 관리 탭의 카드 업데이트
            const historyCard = document.querySelector(`#history [data-scenario-id="${scenarioId}"]`);
            if (historyCard) {
                historyCard.className = `scenario-card ${scenario.status}`;
                const historyStatusBadge = historyCard.querySelector('.status-badge');
                if (historyStatusBadge) {
                    historyStatusBadge.className = `status-badge ${scenario.status}`;
                    historyStatusBadge.textContent = getStatusText(scenario.status);
                }
            }
            
            // 실행/중단 버튼 UI 업데이트
            updateRunStopButtonsUI();
            
            // 녹화 버튼 UI 업데이트
            updateRecordingButtonsUI();
            
            // 요약 카드 업데이트 (두 탭 모두)
            createSummaryCards();
            createSummaryCardsForHistory();
        }

        // 시나리오 모달 열기
        function openScenarioModal(scenarioId) {
            const scenario = scenarios.find(s => s.id === scenarioId);
            if (!scenario) return;

            // 모달 내용 설정
            document.getElementById('modalTitle').textContent = `시나리오 ${scenarioId} 설정`;
            document.getElementById('scenarioTitle').textContent = scenario.title;
            document.getElementById('scenarioDescription').textContent = scenario.description;

            // 기존 설정 불러오기
            loadScenarioSettings(scenarioId);

            // 모달 표시
            document.getElementById('scenarioModal').style.display = 'block';
            
            // 백그라운드 스크롤 비활성화
            document.body.style.overflow = 'hidden';
            
            // 현재 선택된 시나리오 ID 저장
            window.currentScenarioId = scenarioId;
            
            // 원본 녹화 설정 저장 (X 버튼 클릭 시 되돌리기용)
            window.originalRecordingSettings = {
                enabled: recordingSettings[scenarioId] || false,
                folderPath: document.getElementById('modalRecordingFolder').value || ''
            };
        }

        // 시나리오 모달 닫기
        function closeScenarioModal() {
            // 변경사항을 저장하지 않고 모달 닫기
            document.getElementById('scenarioModal').style.display = 'none';
            
            // 백그라운드 스크롤 다시 활성화
            document.body.style.overflow = 'auto';
            
            // 녹화 설정을 원래 상태로 되돌리기
            if (window.currentScenarioId && window.originalRecordingSettings) {
                recordingSettings[window.currentScenarioId] = window.originalRecordingSettings.enabled;
                document.getElementById('modalRecordingFolder').value = window.originalRecordingSettings.folderPath;
                document.getElementById('recordingFolderPath').value = window.originalRecordingSettings.folderPath;
                selectRecordingOption(window.originalRecordingSettings.enabled);
                updateRecordingButtonsUI();
            }
            
            window.currentScenarioId = null;
            window.originalRecordingSettings = null;
        }

        // 녹화 설정 토글
        async function toggleRecording(scenarioId) {
            try {
                // 녹화 설정 전용 모달 표시
                openRecordingSettingsModal(scenarioId);
            } catch (error) {
                console.error('녹화 설정 모달 열기 실패:', error);
                showToast('녹화 설정 모달을 열 수 없습니다.', 'error');
            }
        }

        // 녹화 설정 로드 (Electron 시작 시 모든 녹화 OFF로 초기화)
        async function loadRecordingSettings() {
            try {
                // Electron 시작 시 모든 녹화 설정을 OFF로 초기화
                recordingSettings = {};
                
                // 모든 시나리오의 녹화 설정을 false로 설정
                scenarios.forEach(scenario => {
                    recordingSettings[scenario.id] = false;
                });
                
                // 초기화된 설정을 파일에 저장
                await ipcRenderer.invoke('save-recording-settings', recordingSettings);
                
                // UI 업데이트
                updateRecordingButtonsUI();
                
                console.log('📹 녹화 설정 초기화 완료 (모든 녹화 OFF):', recordingSettings);
            } catch (error) {
                console.error('녹화 설정 초기화 실패:', error);
                // 실패 시 빈 객체로 설정
                recordingSettings = {};
            }
        }

        // 녹화 버튼 UI 업데이트
        function updateRecordingButtonsUI() {
            scenarios.forEach(scenario => {
                const recordingBtn = document.getElementById(`recording-btn-${scenario.id}`);
                const recordingIcon = document.getElementById(`recording-icon-${scenario.id}`);
                const recordText = document.getElementById(`record-text-${scenario.id}`);
                
                if (recordingBtn && recordingIcon && recordText) {
                    const isRecordingEnabled = recordingSettings[scenario.id] || false;
                    const isScenarioRunning = scenario.status === 'running';
                    
                    // 모든 녹화 관련 클래스 제거
                    recordingBtn.classList.remove('recording-on', 'recording-active');
                    
                    if (isRecordingEnabled && isScenarioRunning) {
                        // 녹화 ON + 시나리오 실행 중 = 녹화중
                        recordingBtn.classList.add('recording-active');
                        recordingIcon.className = 'fas fa-stop';
                        recordText.textContent = '녹화중';
                        recordingBtn.title = '현재 녹화 중입니다 (클릭하여 설정 변경)';
                    } else if (isRecordingEnabled) {
                        // 녹화 ON + 시나리오 실행 안함 = 녹화 ON
                        recordingBtn.classList.add('recording-on');
                        recordingIcon.className = 'fas fa-video';
                        recordText.textContent = '녹화 ON';
                        recordingBtn.title = '녹화가 활성화되어 있습니다 (클릭하여 설정 변경)';
                    } else {
                        // 녹화 OFF
                        recordingIcon.className = 'fas fa-video';
                        recordText.textContent = '녹화 OFF';
                        recordingBtn.title = '녹화가 비활성화되어 있습니다 (클릭하여 설정 변경)';
                    }
                }
            });
        }

        // 실행/중단 버튼 UI 업데이트
        function updateRunStopButtonsUI() {
            scenarios.forEach(scenario => {
                const runBtn = document.querySelector(`[onclick*="runScenario(${scenario.id})"]`);
                const stopBtn = document.getElementById(`stop-btn-${scenario.id}`);
                
                if (runBtn && stopBtn) {
                    if (scenario.status === 'running') {
                        // 실행 중일 때: 실행 버튼 숨기고 중단 버튼 표시
                        runBtn.style.display = 'none';
                        stopBtn.style.display = 'flex';
                    } else {
                        // 실행 중이 아닐 때: 실행 버튼 표시하고 중단 버튼 숨기기
                        runBtn.style.display = 'flex';
                        stopBtn.style.display = 'none';
                    }
                }
            });
        }

        // 시나리오 설정 모달의 녹화 옵션 설정
        function setupScenarioModalRecordingOptions() {
            const enabledOption = document.getElementById('recording-enabled-option');
            const disabledOption = document.getElementById('recording-disabled-option');
            const hiddenInput = document.getElementById('modalRecordingEnabled');
            
            if (enabledOption && disabledOption && hiddenInput) {
                // 기존 이벤트 리스너 제거
                enabledOption.removeEventListener('click', enabledOptionClickHandler);
                disabledOption.removeEventListener('click', disabledOptionClickHandler);
                
                // 활성화 옵션 클릭
                enabledOption.addEventListener('click', enabledOptionClickHandler);
                
                // 비활성화 옵션 클릭
                disabledOption.addEventListener('click', disabledOptionClickHandler);
            }
        }
        
        // 녹화 활성화 옵션 클릭 핸들러
        function enabledOptionClickHandler() {
            selectRecordingOption(true);
        }
        
        // 녹화 비활성화 옵션 클릭 핸들러
        function disabledOptionClickHandler() {
            selectRecordingOption(false);
        }

        // 모달 녹화 옵션 설정
        function setupModalRecordingToggle() {
            const enabledOption = document.getElementById('recording-enabled-option');
            const disabledOption = document.getElementById('recording-disabled-option');
            const hiddenInput = document.getElementById('modalRecordingEnabled');
            
            console.log('🔧 setupModalRecordingToggle 호출됨 (시나리오 설정 모달)');
            console.log('  - recording-enabled-option:', enabledOption);
            console.log('  - recording-disabled-option:', disabledOption);
            console.log('  - hiddenInput:', hiddenInput);
            
            if (enabledOption && disabledOption && hiddenInput) {
                console.log('✅ 시나리오 설정 모달 녹화 옵션 이벤트 리스너 등록 중...');
                
                // 활성화 옵션 클릭
                enabledOption.addEventListener('click', function(e) {
                    console.log('🎬 [시나리오 설정 모달] 화면 녹화 활성화 버튼 클릭됨!', e);
                    selectRecordingOption(true);
                });
                
                // 비활성화 옵션 클릭
                disabledOption.addEventListener('click', function(e) {
                    console.log('🚫 [시나리오 설정 모달] 화면 녹화 비활성화 버튼 클릭됨!', e);
                    selectRecordingOption(false);
                });
                
                console.log('✅ 시나리오 설정 모달 녹화 옵션 이벤트 리스너 등록 완료');
            } else {
                console.error('❌ 시나리오 설정 모달 녹화 옵션 요소를 찾을 수 없습니다!');
            }
        }

        // 녹화 폴더 선택
        async function selectRecordingFolder() {
            try {
                console.log('📁 녹화 폴더 선택 요청');
                const result = await ipcRenderer.invoke('select-recording-folder');
                
                if (result.success) {
                    const folderPath = result.folderPath;
                    console.log(`📁 선택된 녹화 폴더: ${folderPath}`);
                    
                    // UI 업데이트
                    document.getElementById('recordingFolderPath').value = folderPath;
                    document.getElementById('modalRecordingFolder').value = folderPath;
                    
                    // 녹화 설정에 폴더 경로 저장
                    const currentScenarioId = window.currentScenarioId || window.currentRecordingScenarioId;
                    if (currentScenarioId) {
                        const recordingFolderSettings = JSON.parse(localStorage.getItem('recordingFolderSettings') || '{}');
                        recordingFolderSettings[currentScenarioId] = folderPath;
                        localStorage.setItem('recordingFolderSettings', JSON.stringify(recordingFolderSettings));
                        
                        console.log(`📁 시나리오 ${currentScenarioId} 녹화 폴더 설정 저장: ${folderPath}`);
                    }
                    
                    showToast('녹화 폴더가 선택되었습니다.', 'success');
                } else {
                    console.error('📁 녹화 폴더 선택 실패:', result.error);
                    showToast('녹화 폴더 선택에 실패했습니다.', 'error');
                }
            } catch (error) {
                console.error('📁 녹화 폴더 선택 중 오류:', error);
                showToast('녹화 폴더 선택 중 오류가 발생했습니다.', 'error');
            }
        }

        // 녹화 설정 모달 열기
        async function openRecordingSettingsModal(scenarioId) {
            try {
                console.log(`📹 시나리오 ${scenarioId} 녹화 설정 모달 열기`);
                
                // 시나리오 정보 설정
                const scenario = scenarios.find(s => s.id === scenarioId);
                if (scenario) {
                    document.getElementById('recordingModalTitle').textContent = scenario.title;
                    document.getElementById('recordingModalDescription').textContent = scenario.description;
                }
                
                // 현재 녹화 설정 로드
                const isCurrentlyEnabled = recordingSettings[scenarioId] || false;
                
                // 파일 시스템에서 녹화 폴더 설정 로드
                let currentFolderPath = '';
                try {
                    const folderResult = await ipcRenderer.invoke('get-user-recording-folder', scenarioId);
                    if (folderResult.success && folderResult.folderPath) {
                        currentFolderPath = folderResult.folderPath;
                        // localStorage도 동기화
                const recordingFolderSettings = JSON.parse(localStorage.getItem('recordingFolderSettings') || '{}');
                        recordingFolderSettings[scenarioId] = currentFolderPath;
                        localStorage.setItem('recordingFolderSettings', JSON.stringify(recordingFolderSettings));
                    }
                } catch (error) {
                    console.log('📁 녹화 폴더 설정 로드 실패, localStorage 사용:', error);
                    const recordingFolderSettings = JSON.parse(localStorage.getItem('recordingFolderSettings') || '{}');
                    currentFolderPath = recordingFolderSettings[scenarioId] || '';
                }
                
                // UI 상태 설정
                document.getElementById('recordingModalEnabled').value = isCurrentlyEnabled.toString();
                document.getElementById('recordingModalFolder').value = currentFolderPath;
                document.getElementById('recordingModalFolderPath').value = currentFolderPath;
                
                // 녹화 옵션 선택 상태 설정
                const enabledOption = document.getElementById('recording-modal-enabled-option');
                const disabledOption = document.getElementById('recording-modal-disabled-option');
                const folderSection = document.getElementById('recordingModalFolderSection');
                
                if (isCurrentlyEnabled) {
                    enabledOption.classList.add('selected');
                    disabledOption.classList.remove('selected');
                    folderSection.style.display = 'block';
                } else {
                    disabledOption.classList.add('selected');
                    enabledOption.classList.remove('selected');
                    folderSection.style.display = 'none';
                }
                
                // 모달 표시
                document.getElementById('recordingModal').style.display = 'flex';
                
                // 배경 스크롤 막기
                document.body.style.overflow = 'hidden';
                
                // 전역 변수 설정
                window.currentRecordingScenarioId = scenarioId;
                
                // 원본 녹화 설정 저장 (X 버튼 클릭 시 되돌리기용)
                window.originalRecordingSettings = {
                    enabled: isCurrentlyEnabled,
                    folderPath: currentFolderPath
                };
                
                // 이벤트 리스너 재등록 (모달이 열릴 때마다 등록)
                setupRecordingModalOptions();
                
                console.log(`📹 녹화 설정 모달 열기 완료: 시나리오 ${scenarioId}`);
                
            } catch (error) {
                console.error('녹화 설정 모달 열기 실패:', error);
                showToast('녹화 설정 모달을 열 수 없습니다.', 'error');
            }
        }

        // 녹화 모달 옵션 클릭 핸들러 (전역 함수로 정의하여 재사용)
        function handleEnabledOptionClick(e) {
            const folderSection = document.getElementById('recordingModalFolderSection');
            console.log('🎬 [녹화 전용 모달] 화면 녹화 활성화 버튼 클릭됨!', e);
            selectRecordingModalOption(true, folderSection);
        }
        
        function handleDisabledOptionClick(e) {
            const folderSection = document.getElementById('recordingModalFolderSection');
            console.log('🚫 [녹화 전용 모달] 화면 녹화 비활성화 버튼 클릭됨!', e);
            selectRecordingModalOption(false, folderSection);
        }

        // 녹화 모달 옵션 설정
        function setupRecordingModalOptions() {
            const enabledOption = document.getElementById('recording-modal-enabled-option');
            const disabledOption = document.getElementById('recording-modal-disabled-option');
            const folderSection = document.getElementById('recordingModalFolderSection');
            const hiddenInput = document.getElementById('recordingModalEnabled');
            
            console.log('🔧 setupRecordingModalOptions 호출됨 (녹화 전용 모달)');
            console.log('  - recording-modal-enabled-option:', enabledOption);
            console.log('  - recording-modal-disabled-option:', disabledOption);
            console.log('  - hiddenInput:', hiddenInput);
            console.log('  - folderSection:', folderSection);
            
            if (enabledOption && disabledOption && hiddenInput) {
                console.log('✅ 녹화 전용 모달 옵션 이벤트 리스너 등록 중...');
                
                // 기존 이벤트 리스너 제거 (중복 방지)
                enabledOption.removeEventListener('click', handleEnabledOptionClick);
                disabledOption.removeEventListener('click', handleDisabledOptionClick);
                
                // 활성화 옵션 클릭
                enabledOption.addEventListener('click', handleEnabledOptionClick);
                
                // 비활성화 옵션 클릭
                disabledOption.addEventListener('click', handleDisabledOptionClick);
                
                console.log('✅ 녹화 전용 모달 옵션 이벤트 리스너 등록 완료');
            } else {
                console.error('❌ 녹화 전용 모달 옵션 요소를 찾을 수 없습니다!');
            }
        }

        // 녹화 모달 옵션 선택
        function selectRecordingModalOption(isEnabled, folderSection) {
            const enabledOption = document.getElementById('recording-modal-enabled-option');
            const disabledOption = document.getElementById('recording-modal-disabled-option');
            const hiddenInput = document.getElementById('recordingModalEnabled');
            
            if (enabledOption && disabledOption && hiddenInput) {
                // UI 상태 업데이트
                if (isEnabled) {
                    enabledOption.classList.add('selected');
                    disabledOption.classList.remove('selected');
                    // 녹화 폴더 섹션 표시
                    if (folderSection) {
                        folderSection.style.display = 'block';
                    }
                } else {
                    disabledOption.classList.add('selected');
                    enabledOption.classList.remove('selected');
                    // 녹화 폴더 섹션 숨김
                    if (folderSection) {
                        folderSection.style.display = 'none';
                    }
                }
                
                // 숨겨진 입력값 업데이트
                hiddenInput.value = isEnabled.toString();
                
                // 녹화 설정 즉시 업데이트하고 UI 반영 (메모리상만, 저장은 하지 않음)
                if (window.currentRecordingScenarioId) {
                    recordingSettings[window.currentRecordingScenarioId] = isEnabled;
                    updateRecordingButtonsUI();
                    console.log(`📹 시나리오 ${window.currentRecordingScenarioId} 녹화 설정 UI 업데이트: ${isEnabled ? '활성화' : '비활성화'}`);
                }
            }
        }

        // 녹화 설정 모달 닫기
        function closeRecordingModal() {
            // 변경사항을 저장하지 않고 모달 닫기
            document.getElementById('recordingModal').style.display = 'none';
            
            // 배경 스크롤 복원
            document.body.style.overflow = '';
            
            // 녹화 설정을 원래 상태로 되돌리기
            if (window.currentRecordingScenarioId && window.originalRecordingSettings) {
                recordingSettings[window.currentRecordingScenarioId] = window.originalRecordingSettings.enabled;
                document.getElementById('recordingModalFolder').value = window.originalRecordingSettings.folderPath;
                document.getElementById('recordingModalFolderPath').value = window.originalRecordingSettings.folderPath;
                selectRecordingModalOption(window.originalRecordingSettings.enabled, document.getElementById('recordingModalFolderSection'));
                updateRecordingButtonsUI();
            }
            
            window.currentRecordingScenarioId = null;
            window.originalRecordingSettings = null;
        }

        // 녹화 설정 모달에서 폴더 선택
        async function selectRecordingModalFolder() {
            try {
                console.log('📁 녹화 모달에서 폴더 선택 요청');
                const result = await ipcRenderer.invoke('select-recording-folder');
                
                if (result.success) {
                    const folderPath = result.folderPath;
                    console.log(`📁 선택된 녹화 폴더: ${folderPath}`);
                    
                    // UI 업데이트
                    document.getElementById('recordingModalFolderPath').value = folderPath;
                    document.getElementById('recordingModalFolder').value = folderPath;
                    
                    showToast('녹화 폴더가 선택되었습니다.', 'success');
                } else {
                    console.error('📁 녹화 모달에서 폴더 선택 실패:', result.error);
                    showToast('녹화 폴더 선택에 실패했습니다.', 'error');
                }
            } catch (error) {
                console.error('📁 녹화 모달에서 폴더 선택 중 오류:', error);
                showToast('녹화 폴더 선택 중 오류가 발생했습니다.', 'error');
            }
        }

        // 녹화 설정 저장
        async function saveRecordingSettings() {
            try {
                const scenarioId = window.currentRecordingScenarioId;
                if (!scenarioId) {
                    showToast('시나리오 ID를 찾을 수 없습니다.', 'error');
                    return;
                }
                
                // 녹화 활성화 여부 확인
                const isEnabled = document.getElementById('recordingModalEnabled').value === 'true';
                const folderPath = document.getElementById('recordingModalFolder').value;
                
                // 녹화 활성화 시 폴더 경로 필수
                if (isEnabled && !folderPath) {
                    showToast('녹화를 활성화하려면 폴더 경로를 선택해주세요.', 'warning');
                    return;
                }
                
                // 녹화 설정 저장
                recordingSettings[scenarioId] = isEnabled;
                await ipcRenderer.invoke('save-recording-setting', scenarioId, isEnabled);
                
                // 폴더 경로 저장
                if (folderPath) {
                    const recordingFolderSettings = JSON.parse(localStorage.getItem('recordingFolderSettings') || '{}');
                    recordingFolderSettings[scenarioId] = folderPath;
                    localStorage.setItem('recordingFolderSettings', JSON.stringify(recordingFolderSettings));
                    
                    // main.js가 읽을 수 있도록 파일에도 저장
                    try {
                        await ipcRenderer.invoke('save-user-recording-folder', scenarioId, folderPath);
                    } catch (error) {
                        console.log('📁 사용자 녹화 폴더 설정 파일 저장 실패:', error);
                    }
                }
                
                // 메인 화면 UI 업데이트
                updateRecordingButtonsUI();
                
                // 설정 모달이 열려있고 같은 시나리오인 경우 모달의 옵션도 업데이트
                if (window.currentScenarioId === scenarioId) {
                    selectRecordingOption(isEnabled);
                }
                
                showToast(`시나리오 ${scenarioId} 녹화 설정이 저장되었습니다.`, 'success');
                
                // 원본 설정 업데이트 (다음 X 버튼 클릭 시 되돌릴 설정)
                window.originalRecordingSettings = {
                    enabled: isEnabled,
                    folderPath: folderPath
                };
                
                closeRecordingModal();
                
                console.log(`📹 시나리오 ${scenarioId} 녹화 설정 저장 완료: ${isEnabled ? '활성화' : '비활성화'}, 폴더: ${folderPath}`);
                
            } catch (error) {
                console.error('녹화 설정 저장 실패:', error);
                showToast('녹화 설정 저장에 실패했습니다.', 'error');
            }
        }


        
        // 녹화 옵션 선택
        function selectRecordingOption(isEnabled) {
            const enabledOption = document.getElementById('recording-enabled-option');
            const disabledOption = document.getElementById('recording-disabled-option');
            const hiddenInput = document.getElementById('modalRecordingEnabled');
            const folderSection = document.getElementById('recordingFolderSection');
            
            if (enabledOption && disabledOption && hiddenInput) {
                // UI 상태 업데이트
                if (isEnabled) {
                    enabledOption.classList.add('selected');
                    disabledOption.classList.remove('selected');
                    // 녹화 폴더 섹션 표시
                    if (folderSection) {
                        folderSection.style.display = 'block';
                    }
                } else {
                    disabledOption.classList.add('selected');
                    enabledOption.classList.remove('selected');
                    // 녹화 폴더 섹션 숨김
                    if (folderSection) {
                        folderSection.style.display = 'none';
                    }
                }
                
                // 숨겨진 입력값 업데이트
                hiddenInput.value = isEnabled.toString();
                
                // 현재 시나리오 ID가 있으면 설정 업데이트 (UI만, 저장은 하지 않음)
                const currentScenarioId = window.currentScenarioId || window.currentRecordingScenarioId;
                if (currentScenarioId) {
                    // 즉시 녹화 설정 업데이트 (메모리상)
                    recordingSettings[currentScenarioId] = isEnabled;
                    
                    // 녹화 버튼 UI 즉시 업데이트
                    updateRecordingButtonsUI();
                    
                    // 실제 저장은 "설정 저장" 버튼을 클릭할 때만 수행됨
                    console.log(`📹 시나리오 ${currentScenarioId} 녹화 설정 UI 업데이트: ${isEnabled ? '활성화' : '비활성화'}`);
                }
            }
        }

        // 커스텀 리포트 열기
        async function openCustomReport(scenarioIdOrPath, event) {
            try {
                // reportPath가 전달된 경우 (히스토리용)
                if (typeof scenarioIdOrPath === 'string' && scenarioIdOrPath.trim() !== '') {
                    console.log(`📊 특정 리포트 파일 열기 요청: ${scenarioIdOrPath}`);
                    console.log(`🔍 전달된 경로 타입: ${typeof scenarioIdOrPath}`);
                    console.log(`🔍 전달된 경로 내용: "${scenarioIdOrPath}"`);
                    console.log(`🔍 경로 길이: ${scenarioIdOrPath.length}`);
                    
                    const result = await ipcRenderer.invoke('open-report-file', scenarioIdOrPath);
                    console.log(`📊 IPC 호출 결과:`, result);
                    
                    if (result.success) {
                        console.log(`✅ 특정 리포트 파일 열기 성공: ${result.path}`);
                        showToast(`리포트가 브라우저에서 열렸습니다.`, 'success');
                    } else {
                        console.error(`❌ 특정 리포트 파일 열기 실패: ${result.error}`);
                        console.error(`❌ 실패한 경로: ${scenarioIdOrPath}`);
                        showToast(`리포트 열기 실패: ${result.error}`, 'error');
                    }
                } else {
                    // scenarioId가 전달된 경우 (기존 방식)
                    const scenarioId = scenarioIdOrPath;
                    console.log(`📊 시나리오 ${scenarioId} 커스텀 리포트 열기 요청`);
                    
                    const result = await ipcRenderer.invoke('open-custom-report', scenarioId);
                    
                    if (result.success) {
                        console.log(`✅ 커스텀 리포트 열기 성공: ${result.path}`);
                        showToast(`시나리오 ${scenarioId} 커스텀 리포트가 브라우저에서 열렸습니다.`, 'success');
                        addLog(`시나리오 ${scenarioId} 커스텀 리포트를 열었습니다.`, 'info', scenarioId);
                    } else {
                        console.error(`❌ 커스텀 리포트 열기 실패: ${result.error}`);
                        showToast(`커스텀 리포트 열기 실패: ${result.error}`, 'error');
                        addLog(`시나리오 ${scenarioId} 커스텀 리포트 열기 실패: ${result.error}`, 'error', scenarioId);
                    }
                }
            } catch (error) {
                console.error(`❌ 커스텀 리포트 열기 중 오류:`, error);
                showToast(`커스텀 리포트 열기 중 오류가 발생했습니다.`, 'error');
                if (typeof scenarioIdOrPath === 'string' && !scenarioIdOrPath.includes('/')) {
                    addLog(`시나리오 ${scenarioIdOrPath} 커스텀 리포트 열기 중 오류: ${error.message}`, 'error', scenarioIdOrPath);
                }
            }
        }



        // test-settings.json 파일에서 설정 불러오기 (시나리오별)
        async function loadScenarioSettings(scenarioId) {
            try {
                // Electron의 IPC를 통해 시나리오별 설정 로드
                const result = await ipcRenderer.invoke('load-scenario-settings', scenarioId);
                
                if (result.success) {
                    const settings = result.data;
                    
                    // 폼에 현재 설정값 채우기
                    document.getElementById('modalUserId').value = settings.login?.userId || '';
                    document.getElementById('modalPassword').value = settings.login?.password || '';
                    document.getElementById('modalProjectCode').value = settings.project?.code || '';
                    document.getElementById('modalProjectName').value = settings.project?.name || '';
                    document.getElementById('modalRepositoryName').value = settings.repository?.name || '';
                    // 사용자 설정 주석처리됨
                    // document.getElementById('modalUserName').value = settings.user?.name || '';
                    // document.getElementById('modalUserEmail').value = settings.user?.email || '';
                    // document.getElementById('modalUserLevel').value = settings.user?.level || '대리(03)';
                    // document.getElementById('modalUserRole').value = settings.user?.role || '빌드배포 관리자';
                    // document.getElementById('modalSystemRole').value = settings.user?.systemRole || '시스템관리자(사용자)';
                    
                    // 사용자 목록 로드
                    loadUsersList(settings.users || []);
                    
                    // 녹화 설정 로드
                    const recordingEnabled = recordingSettings[scenarioId] || false;
                    document.getElementById('modalRecordingEnabled').value = recordingEnabled.toString();
                    
                    // 녹화 폴더 설정 로드
                    let recordingFolderPath = '';
                    try {
                        const folderResult = await ipcRenderer.invoke('get-user-recording-folder', scenarioId);
                        if (folderResult.success && folderResult.folderPath) {
                            recordingFolderPath = folderResult.folderPath;
                            // localStorage도 동기화
                            const recordingFolderSettings = JSON.parse(localStorage.getItem('recordingFolderSettings') || '{}');
                            recordingFolderSettings[scenarioId] = recordingFolderPath;
                            localStorage.setItem('recordingFolderSettings', JSON.stringify(recordingFolderSettings));
                        }
                    } catch (error) {
                        console.log('📁 녹화 폴더 설정 로드 실패, localStorage 사용:', error);
                        const recordingFolderSettings = JSON.parse(localStorage.getItem('recordingFolderSettings') || '{}');
                        recordingFolderPath = recordingFolderSettings[scenarioId] || '';
                    }
                    
                    document.getElementById('modalRecordingFolder').value = recordingFolderPath;
                    document.getElementById('recordingFolderPath').value = recordingFolderPath;
                    
                    selectRecordingOption(recordingEnabled);
                    
                    // 녹화 옵션 클릭 이벤트 설정
                    setupScenarioModalRecordingOptions();
                } else {
                    addLog(`시나리오 ${scenarioId} 설정 로드 실패: ${result.error}`, 'error', scenarioId);
                }
            } catch (error) {
                addLog(`시나리오 ${scenarioId} 설정 로드 실패: ${error.message}`, 'error', scenarioId);
            }
        }

        // test-settings.json 파일에 설정 저장 (시나리오별)
        async function saveScenarioSettings() {
            if (!window.currentScenarioId) return;

            const settings = {
                login: {
                    userId: document.getElementById('modalUserId').value,
                    password: document.getElementById('modalPassword').value
                },
                project: {
                    code: document.getElementById('modalProjectCode').value,
                    name: document.getElementById('modalProjectName').value
                },
                repository: {
                    name: document.getElementById('modalRepositoryName').value
                },
                // 사용자 설정 주석처리됨
                // user: {
                //     id: document.getElementById('modalUserId').value,
                //     name: document.getElementById('modalUserName').value,
                //     email: document.getElementById('modalUserEmail').value,
                //     level: document.getElementById('modalUserLevel').value,
                //     role: document.getElementById('modalUserRole').value,
                //     systemRole: document.getElementById('modalSystemRole').value
                // },
                users: getUsersList(),
                scenario: {
                    id: window.currentScenarioId,
                    type: `scenario_${window.currentScenarioId}`,
                    description: `시나리오 ${window.currentScenarioId} 설정`
                }
            };

            try {
                // 녹화 설정 저장
                const recordingEnabled = document.getElementById('modalRecordingEnabled').value === 'true';
                const recordingFolderPath = document.getElementById('modalRecordingFolder').value;
                
                await ipcRenderer.invoke('save-recording-setting', window.currentScenarioId, recordingEnabled);
                recordingSettings[window.currentScenarioId] = recordingEnabled;
                
                // 녹화 폴더 설정 저장
                if (recordingFolderPath) {
                    await ipcRenderer.invoke('save-user-recording-folder', window.currentScenarioId, recordingFolderPath);
                    const recordingFolderSettings = JSON.parse(localStorage.getItem('recordingFolderSettings') || '{}');
                    recordingFolderSettings[window.currentScenarioId] = recordingFolderPath;
                    localStorage.setItem('recordingFolderSettings', JSON.stringify(recordingFolderSettings));
                }
                
                // 시나리오 카드의 녹화 버튼 상태 업데이트
                const recordingBtn = document.getElementById(`recording-btn-${window.currentScenarioId}`);
                if (recordingBtn) {
                    if (recordingEnabled) {
                        recordingBtn.classList.add('active');
                        recordingBtn.title = '화면 녹화 활성화됨 (클릭하여 비활성화)';
                    } else {
                        recordingBtn.classList.remove('active');
                        recordingBtn.title = '화면 녹화 비활성화됨 (클릭하여 활성화)';
                    }
                }
                
                // Electron의 IPC를 통해 시나리오별 파일 저장
                const result = await ipcRenderer.invoke('save-test-settings', settings, window.currentScenarioId);
                if (result.success) {
                    // 원본 설정 업데이트 (다음 X 버튼 클릭 시 되돌릴 설정)
                    window.originalRecordingSettings = {
                        enabled: recordingEnabled,
                        folderPath: recordingFolderPath
                    };
                    
                    // 성공 알림
                    showNotification('✅ 설정 저장 완료', `시나리오 ${window.currentScenarioId} 설정이 성공적으로 저장되었습니다.`, 'success');
                    addLog(`시나리오 ${window.currentScenarioId} 설정이 성공적으로 저장되었습니다.`, 'success', window.currentScenarioId);
                } else {
                    // 실패 알림
                    showNotification('❌ 설정 저장 실패', `저장 중 오류가 발생했습니다: ${result.error}`, 'error');
                    addLog(`시나리오 ${window.currentScenarioId} 설정 저장 실패: ${result.error}`, 'error', window.currentScenarioId);
                }
            } catch (error) {
                // 오류 알림
                showNotification('❌ 설정 저장 실패', `저장 중 오류가 발생했습니다: ${error.message}`, 'error');
                addLog(`시나리오 ${window.currentScenarioId} 설정 저장 실패: ${error.message}`, 'error', window.currentScenarioId);
            }
        }

        // 알림 표시 함수
        function showNotification(title, message, type = 'info') {
            // 기존 알림 제거
            const existingNotifications = document.querySelectorAll('.notification');
            existingNotifications.forEach(notification => {
                notification.remove();
            });

            // 새 알림 생성
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `
                <button class="notification-close" onclick="closeNotification(this)">×</button>
                <div class="notification-title">${title}</div>
                <div class="notification-message">${message}</div>
            `;

            // 알림을 body에 추가
            document.body.appendChild(notification);

            // 애니메이션을 위한 지연
            setTimeout(() => {
                notification.classList.add('show');
            }, 100);

            // 4초 후 자동 제거
            setTimeout(() => {
                closeNotification(notification.querySelector('.notification-close'));
            }, 4000);
        }

        // 알림 닫기 함수
        function closeNotification(closeButton) {
            const notification = closeButton.closest('.notification');
            if (notification) {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 400);
            }
        }

        // 설정 모달에서 시나리오 실행
        async function runScenarioWithSettings() {
            console.log('runScenarioWithSettings 함수 호출됨');
            console.log('window.currentScenarioId:', window.currentScenarioId);
            
            if (!window.currentScenarioId) {
                console.error('currentScenarioId가 없습니다.');
                return;
            }

            // 시나리오 ID 보존
            const scenarioId = window.currentScenarioId;
            console.log('보존된 scenarioId:', scenarioId);

            // 모달 닫기
            closeScenarioModal();

            // 시나리오 실행
            console.log('runScenario 호출 전');
            await runScenario(scenarioId);
            console.log('runScenario 호출 후');
        }

        // 화면에 디버깅 로그 표시
        function addDebugLogToScreen(message) {
            // 디버깅 로그 창이 없으면 생성
            let debugLogContainer = document.getElementById('debugLogContainer');
            if (!debugLogContainer) {
                debugLogContainer = document.createElement('div');
                debugLogContainer.id = 'debugLogContainer';
                debugLogContainer.style.cssText = `
                    position: fixed;
                    top: 10px;
                    right: 10px;
                    width: 500px;
                    max-height: 400px;
                    background: rgba(0, 0, 0, 0.95);
                    color: #00ff00;
                    font-family: monospace;
                    font-size: 11px;
                    padding: 15px;
                    border-radius: 8px;
                    overflow-y: auto;
                    z-index: 10000;
                    border: 2px solid #00ff00;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                `;
                
                // 닫기 버튼 추가
                const closeBtn = document.createElement('button');
                closeBtn.innerHTML = '❌';
                closeBtn.style.cssText = `
                    position: absolute;
                    top: 5px;
                    right: 5px;
                    background: none;
                    border: none;
                    color: #00ff00;
                    font-size: 16px;
                    cursor: pointer;
                    padding: 2px;
                `;
                closeBtn.onclick = () => debugLogContainer.remove();
                debugLogContainer.appendChild(closeBtn);
                
                document.body.appendChild(debugLogContainer);
            }
            
            // 로그 메시지 추가
            const logEntry = document.createElement('div');
            logEntry.style.cssText = 'margin-bottom: 3px; word-wrap: break-word; line-height: 1.3;';
            logEntry.textContent = `[${new Date().toLocaleTimeString('ko-KR')}] ${message}`;
            debugLogContainer.appendChild(logEntry);
            
            // 스크롤을 맨 아래로
            debugLogContainer.scrollTop = debugLogContainer.scrollHeight;
            
            // 최대 200개 로그만 유지
            while (debugLogContainer.children.length > 201) { // 200개 + 닫기 버튼
                debugLogContainer.removeChild(debugLogContainer.children[1]); // 첫 번째 로그 메시지 제거 (닫기 버튼 제외)
            }
            
            // 콘솔에도 출력
            console.log(message);
        }

        // 디버깅용 로그 (콘솔에만 출력)
        function showDebugLog(message) {
            console.log(message);
        }

        // 로그 추가
        function addLog(message, level = 'info', scenarioId = null) {
            const timestamp = new Date(); // Date 객체로 저장
            const logEntry = {
                timestamp,
                message,
                level,
                scenarioId
            };

            // 기존 잘못된 timestamp 데이터 정리 (한 번만 실행)
            if (!window.timestampCleanupDone) {
                cleanupInvalidTimestamps();
                window.timestampCleanupDone = true;
            }

            // 전체 로그에 추가
            if (!scenarioLogs['all']) {
                scenarioLogs['all'] = [];
            }
            scenarioLogs['all'].push(logEntry);

            // 특정 시나리오 로그에 추가
            if (scenarioId) {
                if (!scenarioLogs[scenarioId]) {
                    scenarioLogs[scenarioId] = [];
                }
                scenarioLogs[scenarioId].push(logEntry);
                
                // 해당 시나리오의 로그창이 열려있다면 실시간 업데이트 (시나리오 목록 탭)
                updateScenarioLogView(scenarioId);
                
                // 이력 관리 탭의 로그창도 실시간 업데이트
                updateHistoryScenarioLogView(scenarioId);
            }



            // 콘솔에도 출력 (디버깅용, 원본 console.log 사용하여 무한 재귀 방지)
            if (window._originalConsoleLog) {
                window._originalConsoleLog(`[${timestamp.toLocaleString('ko-KR')}] [${level.toUpperCase()}] ${message}${scenarioId ? ` (시나리오 ${scenarioId})` : ''}`);
            }
        }

        // 실행 로그를 .txt 파일로 저장하는 함수
        function saveLogsToFile() {
            if (!scenarioLogs['all'] || scenarioLogs['all'].length === 0) {
                alert('저장할 로그가 없습니다.');
                return;
            }

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const fileName = `execution-logs-${timestamp}.txt`;
            
            let logContent = '=== TROMBONE UI 테스트 실행 로그 ===\n';
            logContent += `생성 시간: ${new Date().toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' })}\n`;
            logContent += `총 로그 수: ${scenarioLogs['all'].length}개\n\n`;
            
            scenarioLogs['all'].forEach((log, index) => {
                const logTime = log.timestamp instanceof Date ? 
                    log.timestamp.toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' }) : 
                    new Date(log.timestamp).toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' });
                
                logContent += `[${index + 1}] ${logTime} [${log.level.toUpperCase()}]`;
                if (log.scenarioId) {
                    logContent += ` (시나리오 ${log.scenarioId})`;
                }
                logContent += `\n${log.message}\n\n`;
            });

            // 파일 다운로드
            const blob = new Blob([logContent], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // 원본 console.log 사용 (무한 재귀 방지)
            if (window._originalConsoleLog) {
                window._originalConsoleLog(`📄 로그 파일 저장 완료: ${fileName}`);
            }
        }

        // 특정 시나리오의 로그를 .txt 파일로 저장하는 함수
        function saveScenarioLogsToFile(scenarioId) {
            if (!scenarioLogs[scenarioId] || scenarioLogs[scenarioId].length === 0) {
                alert(`시나리오 ${scenarioId}에 저장할 로그가 없습니다.`);
                return;
            }

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const fileName = `scenario-${scenarioId}-logs-${timestamp}.txt`;
            
            let logContent = `=== TROMBONE UI 테스트 시나리오 ${scenarioId} 실행 로그 ===\n`;
            logContent += `생성 시간: ${new Date().toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' })}\n`;
            logContent += `시나리오 ID: ${scenarioId}\n`;
            logContent += `총 로그 수: ${scenarioLogs[scenarioId].length}개\n\n`;
            
            scenarioLogs[scenarioId].forEach((log, index) => {
                const logTime = log.timestamp instanceof Date ? 
                    log.timestamp.toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' }) : 
                    new Date(log.timestamp).toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' });
                
                logContent += `[${index + 1}] ${logTime} [${log.level.toUpperCase()}] ${log.message}\n\n`;
            });

            // 파일 다운로드
            const blob = new Blob([logContent], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // 원본 console.log 사용 (무한 재귀 방지)
            if (window._originalConsoleLog) {
                window._originalConsoleLog(`📄 시나리오 ${scenarioId} 로그 파일 저장 완료: ${fileName}`);
            }
        }

        // 실행 로그를 리셋하는 함수
        function resetExecutionLogs() {
            // 전체 로그 초기화
            if (scenarioLogs['all']) {
                scenarioLogs['all'] = [];
            }
            
            // 모든 시나리오별 로그 초기화
            Object.keys(scenarioLogs).forEach(key => {
                if (key !== 'all') {
                    scenarioLogs[key] = [];
                }
            });
            

            
            console.log('🧹 실행 로그가 리셋되었습니다.');
        }

        // 터미널 로그를 Electron UI에도 표시하기 위한 console.log 오버라이드
        function setupConsoleLogCapture() {
            const originalConsoleLog = window._originalConsoleLog;
            const originalConsoleError = window._originalConsoleError;
            const originalConsoleWarn = window._originalConsoleWarn;
            const originalConsoleInfo = window._originalConsoleInfo;

            // console.log 오버라이드
            console.log = function(...args) {
                // 원본 console.log 실행
                originalConsoleLog.apply(console, args);
                
                // Electron UI에도 로그 추가 (무한 재귀 방지를 위해 조건 강화)
                const message = args.map(arg => 
                    typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
                ).join(' ');
                
                // 무한 재귀 방지: addLog/addDirectLog에서 호출된 로그는 무시
                if (message && !message.includes('addLog') && !message.includes('[터미널]')) {
                    // 현재 실행 중인 시나리오가 있으면 해당 시나리오의 로그 창에 표시
                    if (currentRunningScenarioIds.size > 0) {
                        const runningScenarioId = Array.from(currentRunningScenarioIds)[0];
                        addDirectLog(`[터미널] ${message}`, 'info', runningScenarioId);
                    } else {
                        addLog(`[터미널] ${message}`, 'info');
                    }
                }
            };

            // console.error 오버라이드
            console.error = function(...args) {
                // 원본 console.error 실행
                originalConsoleError.apply(console, args);
                
                // Electron UI에도 로그 추가 (무한 재귀 방지)
                const message = args.map(arg => 
                    typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
                ).join(' ');
                
                if (message && !message.includes('addLog') && !message.includes('[터미널]')) {
                    // 현재 실행 중인 시나리오가 있으면 해당 시나리오의 로그 창에 표시
                    if (currentRunningScenarioIds.size > 0) {
                        const runningScenarioId = Array.from(currentRunningScenarioIds)[0];
                        addDirectLog(`[터미널 오류] ${message}`, 'error', runningScenarioId);
                    } else {
                        addLog(`[터미널 오류] ${message}`, 'error');
                    }
                }
            };

            // console.warn 오버라이드
            console.warn = function(...args) {
                // 원본 console.warn 실행
                originalConsoleWarn.apply(console, args);
                
                // Electron UI에도 로그 추가 (무한 재귀 방지)
                const message = args.map(arg => 
                    typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
                ).join(' ');
                
                if (message && !message.includes('addLog') && !message.includes('[터미널]')) {
                    // 현재 실행 중인 시나리오가 있으면 해당 시나리오의 로그 창에 표시
                    if (currentRunningScenarioIds.size > 0) {
                        const runningScenarioId = Array.from(currentRunningScenarioIds)[0];
                        addDirectLog(`[터미널 경고] ${message}`, 'warning', runningScenarioId);
                    } else {
                        addLog(`[터미널 경고] ${message}`, 'warning');
                    }
                }
            };

            // console.info 오버라이드
            console.info = function(...args) {
                // 원본 console.info 실행
                originalConsoleInfo.apply(console, args);
                
                // Electron UI에도 로그 추가 (무한 재귀 방지)
                const message = args.map(arg => 
                    typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
                ).join(' ');
                
                if (message && !message.includes('addLog') && !message.includes('[터미널]')) {
                    // 현재 실행 중인 시나리오가 있으면 해당 시나리오의 로그 창에 표시
                    if (currentRunningScenarioIds.size > 0) {
                        const runningScenarioId = Array.from(currentRunningScenarioIds)[0];
                        addDirectLog(`[터미널 정보] ${message}`, 'info', runningScenarioId);
                    } else {
                        addLog(`[터미널 정보] ${message}`, 'info');
                    }
                }
            };

            // 원본 console.log 사용 (무한 재귀 방지)
            if (window._originalConsoleLog) {
                window._originalConsoleLog('✅ 터미널 로그 캡처 설정 완료');
            }
        }

        // 잘못된 timestamp 데이터 정리
        function cleanupInvalidTimestamps() {
            try {
                // 모든 시나리오 로그에서 잘못된 timestamp 정리
                Object.keys(scenarioLogs).forEach(key => {
                    if (Array.isArray(scenarioLogs[key])) {
                        scenarioLogs[key] = scenarioLogs[key].map(log => {
                            // timestamp가 문자열이고 유효하지 않은 경우 현재 시간으로 교체
                            if (typeof log.timestamp === 'string' && log.timestamp.includes('오전') || log.timestamp.includes('오류')) {
                                log.timestamp = new Date();
                            }
                            return log;
                        });
                    }
                });
                console.log('✅ 잘못된 timestamp 데이터 정리 완료');
            } catch (error) {
                console.error('❌ timestamp 데이터 정리 중 오류:', error);
            }
        }

        // 테스트 출력 이벤트 리스너 설정 (setupEventListeners와 통합)
        function setupTestOutputListeners() {
            try {
                console.log('✅ 테스트 출력 이벤트 리스너 설정 완료 (setupEventListeners에서 처리됨)');
            } catch (error) {
                console.error('❌ 테스트 출력 이벤트 리스너 설정 실패:', error);
            }
        }

        // 테스트 출력 처리
        function handleTestOutput(data) {
            try {
                const { testType, data: outputData } = data;
                
                // testType에서 시나리오 ID 추출 (scenario-1 -> 1)
                if (testType && testType.startsWith('scenario-')) {
                    const scenarioId = testType.replace('scenario-', '');
                    
                    // 출력 데이터를 로그에 추가
                    if (outputData && outputData.trim()) {
                        const trimmedData = outputData.trim();
                        
                        // 로그 레벨 결정
                        let level = 'info';
                        if (trimmedData.includes('PASS') || trimmedData.includes('passed')) {
                            level = 'success';
                        } else if (trimmedData.includes('FAIL') || trimmedData.includes('failed')) {
                            level = 'error';
                        } else if (trimmedData.includes('SKIP') || trimmedData.includes('skipped')) {
                            level = 'warning';
                        } else if (trimmedData.includes('Error') || trimmedData.includes('Exception')) {
                            level = 'error';
                        }
                        
                        addLog(`[Playwright] ${trimmedData}`, level, scenarioId);
                    }
                }
            } catch (error) {
                console.error('❌ 테스트 출력 처리 중 오류:', error);
            }
        }

        // 테스트 에러 처리
        function handleTestError(data) {
            try {
                const { testType, data: errorData } = data;
                
                // testType에서 시나리오 ID 추출
                if (testType && testType.startsWith('scenario-')) {
                    const scenarioId = testType.replace('scenario-', '');
                    
                    // 에러 데이터를 로그에 추가
                    if (errorData && errorData.trim()) {
                        addLog(`[Playwright Error] ${errorData.trim()}`, 'error', scenarioId);
                    }
                }
            } catch (error) {
                console.error('❌ 테스트 에러 처리 중 오류:', error);
            }
        }

        // 테스트 타임아웃 처리
        function handleTestTimeout() {
            console.log('⏰ 테스트 타임아웃 발생');
            // 모든 실행 중인 시나리오에 타임아웃 로그 추가
            currentRunningScenarioIds.forEach(scenarioId => {
                addLog('테스트 실행 시간 초과 (5분)', 'warning', scenarioId);
            });
        }

        // 실행 기록에서 리포트 열기 버튼 클릭 처리
        function handleHistoryReportClick(reportPath, scenarioId) {
            try {
                console.log(`🔍 실행 기록 리포트 열기 요청:`);
                console.log(`  - 시나리오 ID: ${scenarioId}`);
                console.log(`  - 리포트 경로: ${reportPath}`);
                console.log(`  - 경로 타입: ${typeof reportPath}`);
                console.log(`  - 경로 길이: ${reportPath.length}`);
                console.log(`  - 경로 내용 (원시): "${reportPath}"`);
                console.log(`  - 경로에 백슬래시 포함: ${reportPath.includes('\\')}`);
                console.log(`  - 경로에 슬래시 포함: ${reportPath.includes('/')}`);
                console.log(`  - 경로에 custom-reports 포함: ${reportPath.includes('custom-reports')}`);
                
                // 경로가 유효한지 확인
                if (reportPath && reportPath.trim() !== '') {
                    console.log(`✅ 리포트 경로 확인됨: ${reportPath}`);
                    console.log(`🚀 openCustomReport 함수 호출 시작...`);
                    
                    // openCustomReport 함수 호출
                    openCustomReport(reportPath);
                } else {
                    console.error(`❌ 잘못된 리포트 경로: ${reportPath}`);
                    showToast('리포트 경로가 올바르지 않습니다.', 'error');
                }
                
            } catch (error) {
                console.error('❌ 실행 기록 리포트 열기 처리 중 오류:', error);
                showToast('리포트 열기 처리 중 오류가 발생했습니다.', 'error');
            }
        }

        // 시나리오 로그창 실시간 업데이트
        function updateScenarioLogView(scenarioId) {
            const logContainer = document.getElementById(`scenario-log-${scenarioId}`);
            if (logContainer && logContainer.style.display !== 'none') {
                const logContent = document.getElementById(`scenario-log-content-${scenarioId}`);
                const logs = scenarioLogs[scenarioId] || [];
                
                // 로그가 새로 추가된 경우에만 새 로그 엔트리를 추가
                const currentLogCount = logContent.children.length;
                if (logs.length > currentLogCount) {
                    // 새로 추가된 로그들만 처리
                    for (let i = currentLogCount; i < logs.length; i++) {
                        const log = logs[i];
                        const logEntry = document.createElement('div');
                        logEntry.className = `log-entry ${log.level}`;
                        
                        // timestamp가 Date 객체인지 확인하고 포맷
                        let timestampStr;
                        if (log.timestamp instanceof Date) {
                            timestampStr = log.timestamp.toLocaleString('ko-KR');
                        } else if (typeof log.timestamp === 'string') {
                            // 기존 문자열 timestamp가 있다면 파싱 시도
                            const parsedDate = new Date(log.timestamp);
                            timestampStr = isNaN(parsedDate.getTime()) ? '시간 정보 없음' : parsedDate.toLocaleString('ko-KR');
                        } else {
                            timestampStr = '시간 정보 없음';
                        }
                        
                        logEntry.innerHTML = `
                            <span class="log-timestamp">[${timestampStr}]</span>
                            ${log.message}
                        `;
                        logContent.appendChild(logEntry);
                    }
                    
                    logContent.scrollTop = logContent.scrollHeight;
                }
            }
        }

        // Expandable section 초기화
        function initializeExpandableSections() {
            // 시나리오별 로그 섹션 생성
            const logsContainer = document.getElementById('logsContainer');
            scenarios.forEach(scenario => {
                const section = createLogSection(scenario);
                logsContainer.appendChild(section);
            });

            // 시나리오별 레포트 섹션 생성
            const reportsContainer = document.getElementById('reportsContainer');
            scenarios.forEach(scenario => {
                const section = createReportSection(scenario);
                reportsContainer.appendChild(section);
            });
        }

        // 로그 섹션 생성
        function createLogSection(scenario) {
            const section = document.createElement('div');
            section.className = 'expandable-section';
            section.id = `logs-section-${scenario.id}`;
            
            section.innerHTML = `
                <div class="expandable-header" onclick="toggleSection('logs-section-${scenario.id}')">
                    <h3>📝 시나리오 ${scenario.id}: ${scenario.title}</h3>
                    <span class="expandable-icon">▼</span>
                </div>
                <div class="expandable-content">
                    <div class="expandable-content-inner">
                        <div class="log-actions">
                            <button class="btn btn-secondary" onclick="clearLogs(${scenario.id})">로그 지우기</button>
                            <button class="btn btn-secondary" onclick="exportLogs(${scenario.id})">로그 내보내기</button>
                        </div>
                        <div class="log-content" id="logContent-${scenario.id}">
                            <div class="log-entry info">
                                <span class="log-timestamp">[${new Date().toLocaleString('ko-KR')}]</span>
                                이 시나리오의 로그가 없습니다.
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            return section;
        }

        // 레포트 섹션 생성
        function createReportSection(scenario) {
            const section = document.createElement('div');
            section.className = 'expandable-section';
            section.id = `reports-section-${scenario.id}`;
            
            section.innerHTML = `
                <div class="expandable-header" onclick="toggleSection('reports-section-${scenario.id}')">
                    <h3>📊 시나리오 ${scenario.id}: ${scenario.title}</h3>
                    <span class="expandable-icon">▼</span>
                </div>
                <div class="expandable-content">
                    <div class="expandable-content-inner">
                        <div class="report-actions">
                            <button class="btn btn-primary" onclick="refreshReport(${scenario.id})">새로고침</button>
                            <button class="btn btn-secondary" onclick="exportReport(${scenario.id})">레포트 내보내기</button>
                        </div>
                        <div class="report-content">
                            <iframe id="reportFrame-${scenario.id}" class="report-frame" src="playwright-report/index.html"></iframe>
                        </div>
                    </div>
                </div>
            `;
            
            return section;
        }

        // 섹션 토글
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            section.classList.toggle('expanded');
        }



        // 전체 로그 지우기
        function clearAllLogs() {
            Object.keys(scenarioLogs).forEach(key => {
                scenarioLogs[key] = [];
            });
            addLog('전체 로그가 초기화되었습니다.', 'info');
        }

        // 전체 펼치기/접기 함수들
        function expandAllLogs() {
            document.querySelectorAll('#logsContainer .expandable-section').forEach(section => {
                section.classList.add('expanded');
            });
        }

        function collapseAllLogs() {
            document.querySelectorAll('#logsContainer .expandable-section').forEach(section => {
                section.classList.remove('expanded');
            });
        }

        function expandAllReports() {
            document.querySelectorAll('#reportsContainer .expandable-section').forEach(section => {
                section.classList.add('expanded');
            });
        }

        function collapseAllReports() {
            document.querySelectorAll('#reportsContainer .expandable-section').forEach(section => {
                section.classList.remove('expanded');
            });
        }

        function refreshAllReports() {
            document.querySelectorAll('#reportsContainer .report-frame').forEach(frame => {
                frame.src = frame.src;
            });
            addLog('전체 레포트를 새로고침했습니다.', 'info');
        }

        // 로그 지우기
        function clearLogs(scenarioId) {
            if (scenarioId === 'all') {
                // 전체 로그 지우기
                Object.keys(scenarioLogs).forEach(key => {
                    scenarioLogs[key] = [];
                });
            } else {
                // 특정 시나리오 로그 지우기
                scenarioLogs[scenarioId] = [];
            }
            
            addLog(`로그가 초기화되었습니다.`, 'info');
        }

        // 로그 내보내기
        function exportLogs(scenarioId) {
            const logs = scenarioLogs[scenarioId] || [];
            
            if (logs.length === 0) {
                addLog('내보낼 로그가 없습니다.', 'warning');
                return;
            }

            const logText = logs.map(log => `[${log.timestamp}] ${log.message}`).join('\n');
            const blob = new Blob([logText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `logs_${scenarioId === 'all' ? 'all' : `scenario_${scenarioId}`}_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            addLog(`로그가 내보내기되었습니다: ${a.download}`, 'success');
        }

        // 레포트 내보내기
        function exportReport(scenarioId) {
            if (scenarioId === 'all') {
                addLog('전체 레포트는 브라우저에서 직접 다운로드해주세요.', 'info');
                return;
            }
            
            const report = scenarioReports[scenarioId];
            if (!report || !report.reportUrl) {
                addLog('내보낼 레포트가 없습니다.', 'warning');
                return;
            }
            
            addLog(`레포트 다운로드 링크: ${report.reportUrl}`, 'info');
        }

        // 레포트 새로고침
        function refreshReport(scenarioId) {
            const reportFrame = document.getElementById(scenarioId === 'all' ? 'allReportFrame' : `reportFrame-${scenarioId}`);
            if (reportFrame) {
                if (scenarioId === 'all') {
                    reportFrame.src = 'playwright-report/index.html';
                } else {
                    reportFrame.src = `playwright-report/scenario-${scenarioId}/index.html`;
                }
                addLog(`레포트를 새로고침했습니다.`, 'info');
            }
        }



        // 현재 실행 중인 시나리오 ID들 추적 (병렬 실행 지원)
        let currentRunningScenarioIds = new Set();

        // 이벤트 리스너 설정
        function setupEventListeners() {
            console.log('🎯 [setupEventListeners] 기타 IPC 리스너 등록 시작');
                    
            // ⚠️ test-output 리스너는 페이지 최상단에서 이미 등록됨 (중복 방지)
            // 여기서는 다른 IPC 이벤트만 처리

            ipcRenderer.on('test-error', (event, data) => {
                // 시나리오별로 로그 구분 처리
                if (data && data.testType && data.data) {
                    // testType에서 시나리오 ID 추출 (예: "scenario-1" -> "1")
                    const scenarioId = data.testType.replace('scenario-', '');
                    if (currentRunningScenarioIds.has(parseInt(scenarioId))) {
                        addLog(data.data, 'error', parseInt(scenarioId));
                    }
                } else {
                    // 기존 형식 호환성 유지
                    currentRunningScenarioIds.forEach(scenarioId => {
                        addLog(data, 'error', scenarioId);
                    });
                }
            });

            // 테스트 중단 이벤트
            ipcRenderer.on('test-stopped', (event, data) => {
                console.log('테스트 중단 이벤트 수신:', data);
                
                if (data && data.testType) {
                    // 특정 시나리오 중단
                    const scenarioId = data.testType.replace('scenario-', '');
                    if (currentRunningScenarioIds.has(parseInt(scenarioId))) {
                        addLog(`시나리오 ${scenarioId} 실행이 중단되었습니다.`, 'warning', parseInt(scenarioId));
                        
                        const scenario = scenarios.find(s => s.id === parseInt(scenarioId));
                        if (scenario) {
                            scenario.status = 'stopped'; // 중단된 상태로 변경
                            updateScenarioCard(parseInt(scenarioId));
                        }
                        
                        currentRunningScenarioIds.delete(parseInt(scenarioId));
                        updateScenarioButtons(parseInt(scenarioId), false);
                    }
                } else {
                    // 모든 시나리오 중단 (기존 로직)
                    currentRunningScenarioIds.forEach(scenarioId => {
                        addLog(`시나리오 ${scenarioId} 실행이 중단되었습니다.`, 'warning', scenarioId);
                        
                        const scenario = scenarios.find(s => s.id === scenarioId);
                        if (scenario) {
                            scenario.status = 'stopped'; // 중단된 상태로 변경
                            updateScenarioCard(scenarioId);
                        }
                        
                        updateScenarioButtons(scenarioId, false);
                    });
                    currentRunningScenarioIds.clear();
                }
            });

            // 테스트 타임아웃 이벤트
            ipcRenderer.on('test-timeout', (event) => {
                console.log('테스트 타임아웃 이벤트 수신');
                // 모든 실행 중인 시나리오를 타임아웃 처리
                currentRunningScenarioIds.forEach(scenarioId => {
                    addLog(`시나리오 ${scenarioId} 실행 시간이 초과되었습니다.`, 'error', scenarioId);
                    
                    const scenario = scenarios.find(s => s.id === scenarioId);
                    if (scenario) {
                        scenario.status = 'fail';
                        updateScenarioCard(scenarioId);
                    }
                    
                    updateScenarioButtons(scenarioId, false);
                });
                currentRunningScenarioIds.clear();
            });

            // 수동으로 닫힌 시나리오들 추적
            let manuallyClosedScenarioIds = new Set();

            // 브라우저 수동 닫기 이벤트
            ipcRenderer.on('browser-closed', (event, data) => {
                console.log('🔄 브라우저 수동 닫기 이벤트 수신:', data);
                console.log('🔄 현재 실행 중인 시나리오들:', Array.from(currentRunningScenarioIds));
                console.log('🔄 수동으로 닫힌 시나리오들:', Array.from(manuallyClosedScenarioIds));
                
                if (data && data.testType) {
                    const scenarioId = data.testType.replace('scenario-', '');
                    const numericScenarioId = parseInt(scenarioId);
                    
                    console.log(`🔄 특정 시나리오 중단 처리: ${scenarioId} (숫자 ID: ${numericScenarioId})`);
                    
                    if (currentRunningScenarioIds.has(numericScenarioId)) {
                        console.log(`🔄 시나리오 ${scenarioId} 상태를 stopped로 변경`);
                        addLog(`브라우저가 수동으로 닫혔습니다. 시나리오 ${scenarioId} 실행이 중단되었습니다.`, 'warning', numericScenarioId);
                        
                        const scenario = scenarios.find(s => s.id === numericScenarioId);
                        if (scenario) {
                            console.log(`🔄 시나리오 ${scenarioId} 이전 상태:`, scenario.status);
                            scenario.status = 'stopped';
                            console.log(`🔄 시나리오 ${scenarioId} 새 상태:`, scenario.status);
                            updateScenarioCard(numericScenarioId);
                        }
                        
                        // 수동으로 닫힌 시나리오로 표시하고 즉시 실행 중인 시나리오에서 제거
                        manuallyClosedScenarioIds.add(numericScenarioId);
                        currentRunningScenarioIds.delete(numericScenarioId);
                        updateScenarioButtons(numericScenarioId, false);
                        
                        console.log(`🔄 시나리오 ${scenarioId} 중단 처리 완료`);
                        console.log(`🔄 수동으로 닫힌 시나리오들:`, Array.from(manuallyClosedScenarioIds));
                        console.log(`🔄 현재 실행 중인 시나리오들 (중단 후):`, Array.from(currentRunningScenarioIds));
                    }
                } else {
                    console.log('🔄 모든 시나리오 중단 처리 시작');
                    const scenarioIdsToStop = Array.from(currentRunningScenarioIds);
                    
                    scenarioIdsToStop.forEach(scenarioId => {
                        console.log(`🔄 시나리오 ${scenarioId} 상태를 stopped로 변경`);
                        addLog(`브라우저가 수동으로 닫혔습니다. 시나리오 ${scenarioId} 실행이 중단되었습니다.`, 'warning', scenarioId);
                        
                        const scenario = scenarios.find(s => s.id === scenarioId);
                        if (scenario) {
                            console.log(`🔄 시나리오 ${scenarioId} 이전 상태:`, scenario.status);
                            scenario.status = 'stopped';
                            console.log(`🔄 시나리오 ${scenarioId} 새 상태:`, scenario.status);
                            updateScenarioCard(scenarioId);
                        }
                        
                        // 수동으로 닫힌 시나리오로 표시
                        manuallyClosedScenarioIds.add(scenarioId);
                        updateScenarioButtons(scenarioId, false);
                    });
                    
                    // 모든 실행 중인 시나리오를 즉시 제거
                    currentRunningScenarioIds.clear();
                    console.log('🔄 모든 시나리오 중단 처리 완료');
                    console.log(`🔄 수동으로 닫힌 시나리오들:`, Array.from(manuallyClosedScenarioIds));
                    console.log(`🔄 현재 실행 중인 시나리오들 (중단 후):`, Array.from(currentRunningScenarioIds));
                }
                
                setTimeout(() => {
                    console.log('🔄 브라우저 닫기 후 상태 초기화 완료');
                }, 1000);
            });

            // 테스트 완료 이벤트
            ipcRenderer.on('test-pass', (event, data) => {
                console.log('✅ test-pass 이벤트 수신 (runScenario에서 이미 처리 완료):', data);
                // runScenario()에서 이미 모든 상태 업데이트를 완료했으므로 여기서는 아무것도 하지 않음
                manuallyClosedScenarioIds.clear();
                currentRunningScenarioIds.clear();
            });

            // 테스트 실패 이벤트 (runScenario에서 이미 모든 처리 완료, 이벤트는 로그용으로만 사용)
            ipcRenderer.on('test-failed', (event, data) => {
                console.log('❌ test-failed 이벤트 수신 (runScenario에서 이미 처리 완료):', data);
                // runScenario()에서 이미 모든 상태 업데이트를 완료했으므로 여기서는 아무것도 하지 않음
                
                // 실시간 로그 상태 업데이트 (완료로 표시)
                currentRunningScenarioIds.forEach(scenarioId => {
                    const statusElement = document.getElementById(`realtime-status-${scenarioId}`);
                    if (statusElement) {
                        statusElement.innerHTML = `
                            <span class="status-indicator" style="
                                width: 8px;
                                height: 8px;
                                border-radius: 50%;
                                background: #95a5a6;
                            "></span>
                            완료 (실패)
                        `;
                    }
                });
                
                manuallyClosedScenarioIds.clear();
                currentRunningScenarioIds.clear();
            });

            // 윈도우 리사이즈 이벤트
            window.addEventListener('resize', () => {
                // 필요한 경우 레이아웃 조정
            });

            // 모달 외부 클릭 시 닫기
            window.addEventListener('click', (event) => {
                const modal = document.getElementById('scenarioModal');
                if (event.target === modal) {
                    closeScenarioModal();
                }
            });

            // ESC 키로 모달 닫기
            window.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    closeScenarioModal();
                }
            });

            // 모달 내부에서 스크롤 이벤트 처리
            document.addEventListener('wheel', (event) => {
                const modal = document.getElementById('scenarioModal');
                if (modal && modal.style.display === 'block') {
                    const modalContent = modal.querySelector('.modal-content');
                    if (modalContent && !modalContent.contains(event.target)) {
                        event.preventDefault();
                    }
                }
            }, { passive: false });
        }

        // 설정 불러오기
        async function loadSettings() {
            try {
                const result = await ipcRenderer.invoke('load-settings');
                if (result.success) {
                    const settings = result.data;
                    
                    document.getElementById('userId').value = settings.login?.userId || '';
                    document.getElementById('password').value = settings.login?.password || '';
                    document.getElementById('projectCode').value = settings.project?.code || '';
                    document.getElementById('projectName').value = settings.project?.name || '';
                    document.getElementById('repositoryName').value = settings.repository?.name || '';
                    document.getElementById('userName').value = settings.user?.name || '';
                    document.getElementById('userEmail').value = settings.user?.email || '';
                    document.getElementById('userLevel').value = settings.user?.level || '주니어(01)';
                    document.getElementById('userRole').value = settings.user?.role || '빌드배포 관리자';
                    document.getElementById('systemRole').value = settings.user?.systemRole || '시스템관리자(사용자)';
                    
                    showSettingsStatus('설정을 성공적으로 불러왔습니다.', 'success');
                } else {
                    showSettingsStatus('설정 파일을 불러올 수 없습니다: ' + result.error, 'error');
                }
            } catch (error) {
                showSettingsStatus('설정 불러오기 중 오류가 발생했습니다: ' + error.message, 'error');
            }
        }

        // 설정 저장
        async function saveSettings() {
            try {
                const settings = {
                    login: {
                        userId: document.getElementById('userId').value,
                        password: document.getElementById('password').value
                    },
                    project: {
                        code: document.getElementById('projectCode').value,
                        name: document.getElementById('projectName').value
                    },
                    repository: {
                        name: document.getElementById('repositoryName').value
                    },
                    user: {
                        id: document.getElementById('userId').value,
                        name: document.getElementById('userName').value,
                        email: document.getElementById('userEmail').value,
                        level: document.getElementById('userLevel').value,
                        role: document.getElementById('userRole').value,
                        systemRole: document.getElementById('systemRole').value
                    }
                };

                const result = await ipcRenderer.invoke('save-settings', settings);
                if (result.success) {
                    showSettingsStatus('설정이 성공적으로 저장되었습니다.', 'success');
                } else {
                    showSettingsStatus('설정 저장 중 오류가 발생했습니다: ' + result.error, 'error');
                }
            } catch (error) {
                showSettingsStatus('설정 저장 중 오류가 발생했습니다: ' + error.message, 'error');
            }
        }

        // 설정 상태 메시지 표시
        function showSettingsStatus(message, type) {
            const statusElement = document.getElementById('settingsStatus');
            statusElement.textContent = message;
            statusElement.className = 'settings-status';
            
            if (type === 'success') {
                statusElement.style.color = '#27ae60';
                statusElement.style.fontWeight = 'bold';
            } else if (type === 'error') {
                statusElement.style.color = '#e74c3c';
                statusElement.style.fontWeight = 'bold';
            } else {
                statusElement.style.color = '#6b7280';
                statusElement.style.fontWeight = 'normal';
            }
            
            // 5초 후 기본 상태로 복원
            setTimeout(() => {
                statusElement.textContent = '💡 설정을 저장한 후 테스트를 실행해주세요.';
                statusElement.style.color = '#6b7280';
                statusElement.style.fontWeight = 'normal';
            }, 5000);
        }

        // 초기 로그 메시지
        addLog('TROMBONE 자동화 테스트 시스템이 시작되었습니다.', 'info');
        
        // 실제 시나리오 파일 개수 가져오기
        try {
            const { ipcRenderer } = require('electron');
            ipcRenderer.invoke('get-scenario-file-count').then(result => {
                const count = result.count;
                addLog(`시나리오 목록이 로드되었습니다. (총 ${count}개)`, 'success');
            }).catch(error => {
                console.error('시나리오 파일 개수 가져오기 실패:', error);
                addLog('시나리오 목록이 로드되었습니다.', 'success');
            });
        } catch (error) {
            console.error('IPC 통신 초기화 실패:', error);
            addLog('시나리오 목록이 로드되었습니다.', 'success');
        }
        
        // 사용자 목록 관리 함수들
        function loadUsersList(users) {
            const usersListContainer = document.getElementById('usersList');
            usersListContainer.innerHTML = '';
            
            if (users && users.length > 0) {
                users.forEach((user, index) => {
                    addUserRow(user);
                });
            } else {
                // 기본 사용자 추가
                addUserRow();
            }
        }

        function addUserRow(userData = null) {
            const usersListContainer = document.getElementById('usersList');
            const userIndex = usersListContainer.children.length;
            
            const userRow = document.createElement('div');
            userRow.className = 'user-row';
            userRow.innerHTML = `
                <div class="user-row-header">
                    <h4>사용자 ${userIndex + 1}</h4>
                    <button type="button" class="btn btn-danger btn-sm" onclick="removeUserRow(this)">삭제</button>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label>사용자 ID</label>
                        <input type="text" class="user-id" value="${userData?.id || ''}" placeholder="예: yh.lee5" style="background-color: #ffffff; color: #333;">
                    </div>
                    <div class="form-group">
                        <label>사용자 이름</label>
                        <input type="text" class="user-name" value="${userData?.name || ''}" placeholder="예: 이영한" style="background-color: #ffffff; color: #333;">
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label>티켓 역할</label>
                        <select class="user-role" style="background-color: #ffffff !important; color: #333 !important;">
                            <option value="빌드배포 관리자" ${userData?.role === '빌드배포 관리자' ? 'selected' : ''}>빌드배포 관리자</option>
                            <option value="테스트담당자" ${userData?.role === '테스트담당자' ? 'selected' : ''}>테스트담당자</option>
                            <option value="개발리더" ${userData?.role === '개발리더' ? 'selected' : ''}>개발리더</option>
                            <option value="개발자" ${userData?.role === '개발자' ? 'selected' : ''}>개발자</option>
                            <option value="결재자" ${userData?.role === '결재자' ? 'selected' : ''}>결재자</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>시스템 역할</label>
                        <select class="user-system-role" style="background-color: #ffffff !important; color: #333 !important;">
                            <option value="시스템관리자(사용자)" ${userData?.systemRole === '시스템관리자(사용자)' ? 'selected' : ''}>시스템관리자(사용자)</option>
                            <option value="솔루션분석팀" ${userData?.systemRole === '솔루션분석팀' ? 'selected' : ''}>솔루션분석팀</option>
                            <option value="라이프사이클" ${userData?.systemRole === '라이프사이클' ? 'selected' : ''}>라이프사이클</option>
                            <option value="티켓(view)" ${userData?.systemRole === '티켓(view)' ? 'selected' : ''}>티켓(view)</option>
                            <option value="BQA" ${userData?.systemRole === 'BQA' ? 'selected' : ''}>BQA</option>
                        </select>
                    </div>
                </div>
            `;
            
            usersListContainer.appendChild(userRow);
        }

        function removeUserRow(button) {
            const userRow = button.closest('.user-row');
            userRow.remove();
            
            // 사용자 번호 재정렬
            const userRows = document.querySelectorAll('.user-row');
            userRows.forEach((row, index) => {
                const header = row.querySelector('.user-row-header h4');
                header.textContent = `사용자 ${index + 1}`;
            });
        }

        function getUsersList() {
            const users = [];
            const userRows = document.querySelectorAll('.user-row');
            
            userRows.forEach(row => {
                const userId = row.querySelector('.user-id').value.trim();
                const userName = row.querySelector('.user-name').value.trim();
                const userRole = row.querySelector('.user-role').value;
                const userSystemRole = row.querySelector('.user-system-role').value;
                
                if (userId && userName) {
                    users.push({
                        id: userId,
                        name: userName,
                        role: userRole,
                        systemRole: userSystemRole
                    });
                }
            });
            
            return users;
        }

        // Toast 알림 함수
        function showToast(message, type = 'info') {
            console.log(`Toast 알림 [${type}]: ${message}`);
            
            // Toast 타입별 설정
            const toastConfig = {
                success: {
                    icon: 'fas fa-check-circle',
                    title: '성공',
                    color: '#10b981'
                },
                error: {
                    icon: 'fas fa-exclamation-circle',
                    title: '오류',
                    color: '#ef4444'
                },
                warning: {
                    icon: 'fas fa-exclamation-triangle',
                    title: '경고',
                    color: '#f59e0b'
                },
                info: {
                    icon: 'fas fa-info-circle',
                    title: '정보',
                    color: '#3b82f6'
                }
            };
            
            const config = toastConfig[type] || toastConfig.info;
            
            // Toast 요소 생성
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <i class="toast-icon ${config.icon}"></i>
                <div class="toast-content">
                    <div class="toast-title">${config.title}</div>
                    <div class="toast-message">${message}</div>
                </div>
                <button class="toast-close" onclick="this.parentElement.remove()">
                    <i class="fas fa-times"></i>
                </button>
            `;
            
            // Toast 컨테이너에 추가
            const container = document.getElementById('toastContainer');
            container.appendChild(toast);
            
            // 애니메이션 시작
            setTimeout(() => {
                toast.classList.add('show');
            }, 100);
            
            // 자동 제거 (5초 후)
            setTimeout(() => {
                toast.classList.add('hide');
                setTimeout(() => {
                    if (toast.parentElement) {
                        toast.remove();
                    }
                }, 400);
            }, 5000);
        }

        // 페이지 로드 시 설정 불러오기
        loadSettings();
        
        // 전역 함수 등록 확인
        console.log('페이지 로드 완료');
        console.log('runSelectedScenarios 함수 등록됨:', typeof window.runSelectedScenarios);

        // 특정 시나리오 중단
        async function stopSpecificScenario(scenarioId) {
            try {
                console.log(`🔄 시나리오 ${scenarioId} 중단 요청`);
                const result = await ipcRenderer.invoke('stop-specific-test', `scenario-${scenarioId}`);
                
                if (result.success) {
                    console.log(`🔄 시나리오 ${scenarioId} 중단 성공`);
                    addLog(`시나리오 ${scenarioId} 테스트가 중단되었습니다.`, 'warning', scenarioId);
                    
                    // 중단된 시나리오를 실패로 처리
                    const scenario = scenarios.find(s => s.id === scenarioId);
                    if (scenario) {
                        scenario.status = 'fail';
                        updateScenarioCard(scenarioId);
                    }
                    
                    updateScenarioButtons(scenarioId, false);
                    currentRunningScenarioIds.delete(scenarioId);
                    
                    // 버튼 상태 업데이트
                    updateSelectedScenarios();
                    
                    // 중단 성공 메시지
                    showToast(`⏹️ 시나리오 ${scenarioId}가 성공적으로 중단되었습니다.`, 'warning');
                } else {
                    console.log(`❌ 시나리오 ${scenarioId} 중단 실패:`, result.error);
                    showToast(`❌ 시나리오 ${scenarioId} 중단 중 오류가 발생했습니다.`, 'error');
                    addLog(`시나리오 ${scenarioId} 중단 중 오류가 발생했습니다: ${result.error}`, 'error', scenarioId);
                }
            } catch (error) {
                console.error(`❌ 시나리오 ${scenarioId} 중단 중 오류:`, error);
                addLog(`시나리오 ${scenarioId} 중단 중 오류가 발생했습니다: ${error.message}`, 'error', scenarioId);
            }
        }



        // 모든 테스트 중단
        async function stopAllTests() {
            try {
                console.log('🔄 모든 테스트 중단 요청');
                const result = await ipcRenderer.invoke('stop-test');
                
                if (result.success) {
                    console.log('🔄 모든 테스트 중단 성공');
                    
                    const stoppedCount = currentRunningScenarioIds.size;
                    
                    // 모든 실행 중인 시나리오를 실패로 처리
                    currentRunningScenarioIds.forEach(scenarioId => {
                        addLog(`시나리오 ${scenarioId} 테스트가 중단되었습니다.`, 'warning', scenarioId);
                        
                        const scenario = scenarios.find(s => s.id === scenarioId);
                        if (scenario) {
                            scenario.status = 'fail';
                            updateScenarioCard(scenarioId);
                        }
                        
                        updateScenarioButtons(scenarioId, false);
                    });
                    
                    currentRunningScenarioIds.clear();
                    
                    // 버튼 상태 업데이트
                    updateSelectedScenarios();
                    
                    // 중단 결과 메시지
                    if (stoppedCount > 0) {
                        showToast(`⏹️ ${stoppedCount}개의 시나리오가 성공적으로 중단되었습니다.`, 'warning');
                    } else {
                        showToast('ℹ️ 실행 중인 시나리오가 없습니다.', 'info');
                    }
                } else {
                    console.log('❌ 모든 테스트 중단 실패:', result.error);
                    showToast('❌ 테스트 중단 중 오류가 발생했습니다.', 'error');
                    addLog(`모든 테스트 중단 중 오류가 발생했습니다: ${result.error}`, 'error');
                }
            } catch (error) {
                console.error('❌ 모든 테스트 중단 중 오류:', error);
                addLog(`모든 테스트 중단 중 오류가 발생했습니다: ${error.message}`, 'error');
            }
        }
    </script>
</body>
</html> 